<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How-Tos &mdash; Krotov 1.3.0 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="_static/mycss.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script src="_static/docs-versions-menu.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/SVG"], "TeX": {"extensions": ["AMSmath.js", "AMSsymbols.js"], "Macros": {"tr": ["{\\operatorname{tr}}", 0], "diag": ["{\\operatorname{diag}}", 0], "abs": ["{\\operatorname{abs}}", 0], "pop": ["{\\operatorname{pop}}", 0], "ee": ["{\\text{e}}", 0], "ii": ["{\\text{i}}", 0], "aux": ["{\\text{aux}}", 0], "opt": ["{\\text{opt}}", 0], "tgt": ["{\\text{tgt}}", 0], "init": ["{\\text{init}}", 0], "lab": ["{\\text{lab}}", 0], "rwa": ["{\\text{rwa}}", 0], "bra": ["{\\langle#1\\vert}", 1], "ket": ["{\\vert#1\\rangle}", 1], "Bra": ["{\\left\\langle#1\\right\\vert}", 1], "Braket": ["{\\left\\langle #1\\vphantom{#2} \\mid #2\\vphantom{#1}\\right\\rangle}", 2], "ketbra": ["{\\vert#1\\rangle\\!\\langle#2\\vert}", 2], "Ket": ["{\\left\\vert#1\\right\\rangle}", 1], "mat": ["{\\mathbf{#1}}", 1], "op": ["{\\hat{#1}}", 1], "Op": ["{\\hat{#1}}", 1], "dd": ["{\\,\\text{d}}", 0], "daggered": ["{^{\\dagger}}", 0], "transposed": ["{^{\\text{T}}}", 0], "Liouville": ["{\\mathcal{L}}", 0], "DynMap": ["{\\mathcal{E}}", 0], "identity": ["{\\mathbf{1}}", 0], "Norm": ["{\\left\\lVert#1\\right\\rVert}", 1], "norm": ["{\\lVert#1\\rVert}", 1], "Abs": ["{\\left\\vert#1\\right\\vert}", 1], "avg": ["{\\langle#1\\rangle}", 1], "Avg": ["{\\left\\langle#1\\right\\rangle}", 1], "AbsSq": ["{\\left\\vert#1\\right\\vert^2}", 1], "Re": ["{\\operatorname{Re}}", 0], "Im": ["{\\operatorname{Im}}", 0], "Real": ["{\\mathbb{R}}", 0], "Complex": ["{\\mathbb{C}}", 0], "Integer": ["{\\mathbb{N}}", 0]}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Other Optimization Methods" href="11_other_methods.html" />
    <link rel="prev" title="Optimization with numpy Arrays" href="notebooks/09_example_numpy.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Krotov
          </a>
              <div class="version">
                1.3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_overview.html">Krotov Python Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_krotovs_method.html">Krotov’s Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_qutip_usage.html">Using Krotov with QuTiP</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">How-Tos</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#how-to-optimize-towards-a-quantum-gate">How to optimize towards a quantum gate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-optimize-complex-valued-control-fields">How to optimize complex-valued control fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-use-args-in-time-dependent-control-fields">How to use <cite>args</cite> in time-dependent control fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-stop-the-optimization-when-the-error-crosses-some-threshold">How to stop the optimization when the error crosses some threshold</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-exclude-a-control-from-the-optimization">How to exclude a control from the optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-define-a-new-optimization-functional">How to define a new optimization functional</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-penalize-population-in-a-forbidden-subspace">How to penalize population in a forbidden subspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-optimize-towards-a-two-qubit-gate-up-to-single-qubit-corrections">How to optimize towards a two-qubit gate up to single-qubit corrections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-optimize-towards-an-arbitrary-perfect-entangler">How to optimize towards an arbitrary perfect entangler</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-optimize-in-a-dissipative-system">How to optimize in a dissipative system</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-optimize-for-robust-pulses">How to optimize for robust pulses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-apply-spectral-constraints">How to apply spectral constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-limit-the-amplitude-of-the-controls">How to limit the amplitude of the controls</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-parallelize-the-optimization">How to parallelize the optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-avoid-over-subscribing-the-cpu-when-using-parallelization">How to avoid over-subscribing the CPU when using parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-prevent-losing-an-optimization-result">How to prevent losing an optimization result</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-continue-from-a-previous-optimization">How to continue from a previous optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-maximize-numerical-efficiency">How to maximize numerical efficiency</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-deal-with-the-optimization-running-out-of-memory">How to deal with the optimization running out of memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-avoid-the-overhead-of-qutip-objects">How to avoid the overhead of QuTiP objects</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="11_other_methods.html">Other Optimization Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_related_software.html">Related Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="99_bibliography.html">References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="API/krotov.html">API of the Krotov package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Krotov</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          





















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>How-Tos</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="how-tos">
<h1>How-Tos<a class="headerlink" href="#how-tos" title="Permalink to this headline">¶</a></h1>
<div class="section" id="how-to-optimize-towards-a-quantum-gate">
<span id="howtogateoptimization"></span><h2>How to optimize towards a quantum gate<a class="headerlink" href="#how-to-optimize-towards-a-quantum-gate" title="Permalink to this headline">¶</a></h2>
<p>To optimize towards a quantum gate <span class="math notranslate nohighlight">\(\Op{O}\)</span> in a <em>closed</em> quantum system,
set one <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective" title="krotov.objectives.Objective"><code class="xref py py-class docutils literal notranslate"><span class="pre">Objective</span></code></a> for each state in the logical basis, with the basis
state <span class="math notranslate nohighlight">\(\ket{\phi_k}\)</span> as the <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.initial_state" title="krotov.objectives.Objective.initial_state"><code class="xref py py-attr docutils literal notranslate"><span class="pre">initial_state</span></code></a> and
<span class="math notranslate nohighlight">\(\Op{O} \ket{\phi_k}\)</span> as the <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.target" title="krotov.objectives.Objective.target"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target</span></code></a>.</p>
<p>You may use <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.gate_objectives" title="krotov.objectives.gate_objectives"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.gate_objectives()</span></code></a>
to construct the appropriate list of objectives. See the
<a class="reference internal" href="notebooks/05_example_transmon_xgate.html"><span class="std std-ref">Optimization of an X-Gate for a Transmon Qubit</span></a> for an example. For more
advanced gate optimizations, also see <a class="reference internal" href="#howtolioptimization"><span class="std std-ref">How to optimize towards a two-qubit gate up to single-qubit corrections</span></a>,
<a class="reference internal" href="#howtopeoptimization"><span class="std std-ref">How to optimize towards an arbitrary perfect entangler</span></a>, <a class="reference internal" href="#howtodissipativeoptimization"><span class="std std-ref">How to optimize in a dissipative system</span></a>, and
<a class="reference internal" href="#howtorobustoptimization"><span class="std std-ref">How to optimize for robust pulses</span></a>.</p>
</div>
<div class="section" id="how-to-optimize-complex-valued-control-fields">
<h2>How to optimize complex-valued control fields<a class="headerlink" href="#how-to-optimize-complex-valued-control-fields" title="Permalink to this headline">¶</a></h2>
<p>This implementation of Krotov’s method requires real-valued control fields. You
must rewrite your Hamiltonian to contain the real part and the imaginary part
of the field as two independent controls. This is always possible. For example,
for a driven harmonic oscillator in the rotating wave approximation, the
interaction Hamiltonian is given by</p>
<div class="math notranslate nohighlight">
\[\Op{H}_\text{int}
= \epsilon^*(t) \Op{a} + \epsilon(t) \Op{a}^\dagger
=  \epsilon_{\text{re}}(t) (\Op{a} + \Op{a}^\dagger) + \epsilon_{\text{im}}(t) (i \Op{a}^\dagger - i \Op{a})\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon_{\text{re}}(t)= \Re[\epsilon(t)]\)</span> and
<span class="math notranslate nohighlight">\(\epsilon_{\text{im}}(t) = \Im[\epsilon(t)]\)</span> are considered as two
independent (real-valued) controls.</p>
<p>See the <a class="reference internal" href="notebooks/02_example_lambda_system_rwa_complex_pulse.html"><span class="std std-ref">Optimization of a State-to-State Transfer in a Lambda System in the RWA</span></a> for an example.</p>
</div>
<div class="section" id="how-to-use-args-in-time-dependent-control-fields">
<span id="howtouseargs"></span><h2>How to use <cite>args</cite> in time-dependent control fields<a class="headerlink" href="#how-to-use-args-in-time-dependent-control-fields" title="Permalink to this headline">¶</a></h2>
<p>QuTiP requires that the functions that are used to express time-dependencies
have the signature <code class="docutils literal notranslate"><span class="pre">func(t,</span> <span class="pre">args)</span></code> where <cite>t</cite> is a scalar value for the time
and <cite>args</cite> is a dict containing values for static parameters, see
<a class="reference external" href="http://qutip.org/docs/latest/guide/dynamics/dynamics-time.html#using-the-args-variable">QuTiP’s documentation on using the args variable</a>. Most of the <a class="reference internal" href="API/krotov.html#module-krotov" title="krotov"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov</span></code></a>
package’s <a class="reference internal" href="09_examples.html#krotov-example-notebooks"><span class="std std-ref">Examples</span></a> use closures or hardcoded values
instead of <cite>args</cite>. For example, in the
<a class="reference internal" href="notebooks/01_example_simple_state_to_state.html"><span class="std std-ref">Optimization of a State-to-State Transfer in a Two-Level-System</span></a>, the Hamiltonian is
defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ampl0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Two-level-system Hamiltonian</span>

<span class="sd">   Args:</span>
<span class="sd">      omega (float): energy separation of the qubit levels</span>
<span class="sd">      ampl0 (float): constant amplitude of the driving field</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">H0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">qutip</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
   <span class="n">H1</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>

   <span class="k">def</span> <span class="nf">guess_control</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">ampl0</span> <span class="o">*</span> <span class="n">krotov</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">flattop</span><span class="p">(</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">t_rise</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s2">&quot;blackman&quot;</span>
      <span class="p">)</span>

   <span class="k">return</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">guess_control</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note how <cite>ampl0</cite> is used in <cite>guess_control</cite> as a <a class="reference external" href="https://www.learnpython.org/en/Closures">closure</a> from the surrounding
<cite>hamiltonian</cite> scope, <cite>t_stop</cite> and <cite>t_rise</cite> are hardcoded, and <cite>args</cite> is not
used at all. The function could be rewritten as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">guess_control</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Initial control amplitude.</span>

<span class="sd">   Args:</span>
<span class="sd">      t (float): Time value at which to evaluate the control.</span>
<span class="sd">      args (dict): Dictionary containing the value &quot;ampl0&quot; with the</span>
<span class="sd">        amplitude of the driving field, &quot;t_stop&quot; with the time at which the</span>
<span class="sd">        control shape ends, and &quot;t_rise&quot; for the duration of the</span>
<span class="sd">        switch-on/switch-off time.</span>
<span class="sd">   &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;ampl0&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">krotov</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">flattop</span><span class="p">(</span>
        <span class="n">t</span><span class="p">,</span>
        <span class="n">t_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">t_stop</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;t_stop&#39;</span><span class="p">],</span>
        <span class="n">t_rise</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;t_rise&#39;</span><span class="p">],</span>
        <span class="n">func</span><span class="o">=</span><span class="s2">&quot;blackman&quot;</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Two-level-system Hamiltonian</span>

<span class="sd">    Args:</span>
<span class="sd">        omega (float): energy separation of the qubit levels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">qutip</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
    <span class="n">H1</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">guess_control</span><span class="p">]]</span>

<span class="n">ARGS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ampl0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">t_stop</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">t_rise</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>ARGS</cite> must be passed to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> via the <cite>pulse_options</cite>
parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pulse_options</span> <span class="o">=</span> <span class="p">{</span>
   <span class="n">guess_control</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lambda_a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">update_shape</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">ARGS</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.mesolve" title="krotov.objectives.Objective.mesolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Objective.mesolve()</span></code></a> and <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.propagate" title="krotov.objectives.Objective.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Objective.propagate()</span></code></a> take an
optional <cite>args</cite> dict also.</p>
<p>The <cite>args</cite> in <cite>pulse_options</cite> are used automatically when evaluating the
respective initial guess.  Note that the use of <cite>args</cite> does not extend
to <cite>update_shape</cite>, which is always a function of <cite>t</cite> only.  Any other
parameters in the <cite>update_shape</cite> are best set via <a class="reference external" href="https://docs.python.org/3.7/library/functools.html#functools.partial" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>,
see the <a class="reference internal" href="notebooks/03_example_lambda_system_rwa_non_hermitian.html"><span class="std std-ref">Optimization of a Dissipative State-to-State Transfer in a Lambda System</span></a>.</p>
<p>Compare that example to the
<a class="reference internal" href="notebooks/02_example_lambda_system_rwa_complex_pulse.html"><span class="std std-ref">Optimization of a State-to-State Transfer in a Lambda System in the RWA</span></a>.
In the latter, the values for the parameters in the control fields and the
Hamiltonian are hardcoded, while in the former, all parameters are centrally
defined in a dict which is passed to the optimization and propagation routines.</p>
</div>
<div class="section" id="how-to-stop-the-optimization-when-the-error-crosses-some-threshold">
<h2>How to stop the optimization when the error crosses some threshold<a class="headerlink" href="#how-to-stop-the-optimization-when-the-error-crosses-some-threshold" title="Permalink to this headline">¶</a></h2>
<p>By default, an optimization stops after a predefined number of iterations
(<cite>iter_stop</cite> parameter in <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>). However, through the
interplay of the <cite>info_hook</cite> and the <cite>check_convergence</cite> routine  passed to
<a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>, the optimization can be stopped based on the
optimization success or the rate of convergence: The <cite>info_hook</cite> routine should
return the value of the optimization functional or error, which is accessible to
<cite>check_convergence</cite> via the <a class="reference internal" href="API/krotov.result.html#krotov.result.Result.info_vals" title="krotov.result.Result.info_vals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Result.info_vals</span></code></a> attribute, see
<a class="reference internal" href="API/krotov.convergence.html#module-krotov.convergence" title="krotov.convergence"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.convergence</span></code></a> for details.</p>
<p>Generally, you should use the <a class="reference internal" href="API/krotov.info_hooks.html#krotov.info_hooks.print_table" title="krotov.info_hooks.print_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.info_hooks.print_table()</span></code></a> function as
an <cite>info_hook</cite>, which receives a function to evaluate the optimization
functional <span class="math notranslate nohighlight">\(J_T\)</span> as a parameter. Then, use
<a class="reference internal" href="API/krotov.convergence.html#krotov.convergence.value_below" title="krotov.convergence.value_below"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.convergence.value_below()</span></code></a> as a <cite>check_convergence</cite> routine to stop
the optimization when <span class="math notranslate nohighlight">\(J_T\)</span> falls below some given threshold.</p>
<p>See the thee <a class="reference internal" href="notebooks/02_example_lambda_system_rwa_complex_pulse.html"><span class="std std-ref">Optimization of a State-to-State Transfer in a Lambda System in the RWA</span></a> for
an example.</p>
</div>
<div class="section" id="how-to-exclude-a-control-from-the-optimization">
<h2>How to exclude a control from the optimization<a class="headerlink" href="#how-to-exclude-a-control-from-the-optimization" title="Permalink to this headline">¶</a></h2>
<p>In order to force the optimization to leave any particular control field
unchanged, set its update shape to <a class="reference internal" href="API/krotov.shapes.html#krotov.shapes.zero_shape" title="krotov.shapes.zero_shape"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.shapes.zero_shape()</span></code></a>
in the <cite>pulse_options</cite> that you pass to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>.</p>
</div>
<div class="section" id="how-to-define-a-new-optimization-functional">
<h2>How to define a new optimization functional<a class="headerlink" href="#how-to-define-a-new-optimization-functional" title="Permalink to this headline">¶</a></h2>
<p>In order to define a new optimization functional <span class="math notranslate nohighlight">\(J_T\)</span>:</p>
<ul>
<li><p>Decide on what should go in <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.target" title="krotov.objectives.Objective.target"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Objective.target</span></code></a> to best describe the
<em>physical</em> control target. If the control target is reached when the
<a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.initial_state" title="krotov.objectives.Objective.initial_state"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Objective.initial_state</span></code></a> evolves to a specific target state under the
optimal control fields, that target state should be included in
<a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.target" title="krotov.objectives.Objective.target"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target</span></code></a>.</p></li>
<li><p>Define a function <cite>chi_constructor</cite> that calculates the boundary
condition for the backward-propagation in Krotov’s method,</p>
<div class="math notranslate nohighlight">
\[\ket{\chi_k(T)} \equiv - \left. \frac{\partial J_T}{\partial \bra{\phi_k(T)}} \right\vert_{\ket{\phi_k(T)}}\,,\]</div>
<p>or the equivalent experession in Liouville space. This function should
calculate the states <span class="math notranslate nohighlight">\(\ket{\chi_k}\)</span> based  on the forward-propagated
states <span class="math notranslate nohighlight">\(\ket{\phi_k(T)}\)</span> and the list of objectives. For convenience,
when <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.target" title="krotov.objectives.Objective.target"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target</span></code></a> contains a target state, <cite>chi_constructor</cite>
will also receive <cite>tau_vals</cite> containing the overlaps <span class="math notranslate nohighlight">\(\tau_k =
\Braket{\phi_k^{\tgt}}{\phi_k(T)}\)</span>. See <a class="reference internal" href="API/krotov.functionals.html#krotov.functionals.chis_re" title="krotov.functionals.chis_re"><code class="xref py py-func docutils literal notranslate"><span class="pre">chis_re()</span></code></a> for an example.</p>
</li>
<li><p>Optionally, define a function that can be used as an <cite>info_hook</cite>
in <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> which returns the value
<span class="math notranslate nohighlight">\(J_T\)</span>. This is not required to run an optimization since the
functional is entirely implicit in <cite>chi_constructor</cite>. However, calculating
the value of the functional is useful for convergence analysis
(<cite>check_convergence</cite> in <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>)</p></li>
</ul>
<p>See <a class="reference internal" href="API/krotov.functionals.html#module-krotov.functionals" title="krotov.functionals"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.functionals</span></code></a> for some standard functionals. An example for a
more advanced functional is the <a class="reference internal" href="notebooks/07_example_PE.html"><span class="std std-ref">Optimization towards a Perfect Entangler</span></a>.</p>
</div>
<div class="section" id="how-to-penalize-population-in-a-forbidden-subspace">
<h2>How to penalize population in a forbidden subspace<a class="headerlink" href="#how-to-penalize-population-in-a-forbidden-subspace" title="Permalink to this headline">¶</a></h2>
<p>In principle, <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> has a <cite>state_dependent_constraint</cite>.
However, this has some caveats. Most notably, it results in an inhomogeneous
equation of motion, which is currently not implemented.</p>
<p>The recommended “workaround” is to place artificially high dissipation on the
levels in the forbidden subspace. A non-Hermitian Hamiltonian is usually a
good way to realize this. See the
<a class="reference internal" href="notebooks/03_example_lambda_system_rwa_non_hermitian.html"><span class="std std-ref">Optimization of a Dissipative State-to-State Transfer in a Lambda System</span></a>
for an example.</p>
</div>
<div class="section" id="how-to-optimize-towards-a-two-qubit-gate-up-to-single-qubit-corrections">
<span id="howtolioptimization"></span><h2>How to optimize towards a two-qubit gate up to single-qubit corrections<a class="headerlink" href="#how-to-optimize-towards-a-two-qubit-gate-up-to-single-qubit-corrections" title="Permalink to this headline">¶</a></h2>
<p>On many quantum computing platforms, applying arbitrary single-qubit
gates is easy compared to entangling two-qubit gates. A specific
entangling gate like CNOT is combined with single-qubit gates to form a
universal set of gates. For a given physical system, it can be hard to
know a-priori which entangling gates are easy or even possible to
realize. For example, trapped neutral atoms only allow for the
realization of diagonal two-qubit
gates <span id="id1">[<a class="reference internal" href="99_bibliography.html#id19" title="M. H. Goerz, D. M. Reich, and C. P. Koch. Optimal control theory for a unitary operation under dissipative evolution. New J. Phys.  16, 055012 (2014). doi:10.1088/1367-2630/16/5/055012.">27</a>, <a class="reference internal" href="99_bibliography.html#id84" title="D. Jaksch, J. I. Cirac, P. Zoller, S. L. Rolston, R. Côté, and M. D. Lukin. Fast quantum gates for neutral atoms. Phys. Rev. Lett.  85, 2208 (2000). doi:10.1103/PhysRevLett.85.2208.">54</a>]</span> like CPHASE.
However, the CPHASE gate is “locally equivalent” to CNOT: only
additional single-qubit operations are required to obtain one from the
other. A “local-invariants functional” <span id="id2">[<a class="reference internal" href="99_bibliography.html#id21" title="M. M. Müller, D. M. Reich, M. Murphy, H. Yuan, J. Vala, K. B. Whaley, T. Calarco, and C. P. Koch. Optimizing entangling quantum gates for physical systems. Phys. Rev. A  84, 042315 (2011). doi:10.1103/PhysRevA.84.042315.">55</a>]</span>
defines an optimization with respect to a such a local equivalence
class, and thus is free to find the specific realization of a two-qubit
gate that is easiest to realize.</p>
<p>Use <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.gate_objectives" title="krotov.objectives.gate_objectives"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.objectives.gate_objectives()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">local_invariants=True</span></code> in
order to construct a list of objectives suitable for an optimization using the
local-invariant functional <span id="id3">[<a class="reference internal" href="99_bibliography.html#id21" title="M. M. Müller, D. M. Reich, M. Murphy, H. Yuan, J. Vala, K. B. Whaley, T. Calarco, and C. P. Koch. Optimizing entangling quantum gates for physical systems. Phys. Rev. A  84, 042315 (2011). doi:10.1103/PhysRevA.84.042315.">55</a>]</span>. This optimizes towards a
point in the <a class="reference external" href="https://weylchamber.readthedocs.io/en/latest/tutorial.html">Weyl chamber</a>.</p>
<p>The <a class="reference external" href="https://github.com/qucontrol/weylchamber"><code class="docutils literal notranslate"><span class="pre">weylchamber</span></code> package</a> contains the suitable <cite>chi_constructor</cite> routines to
pass to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>.</p>
<p>The optimization towards a local equivalence class may require use of the
second-order update equation, see <a class="reference internal" href="07_krotovs_method.html#secondorderupdate"><span class="std std-ref">Second order update</span></a>.</p>
</div>
<div class="section" id="how-to-optimize-towards-an-arbitrary-perfect-entangler">
<span id="howtopeoptimization"></span><h2>How to optimize towards an arbitrary perfect entangler<a class="headerlink" href="#how-to-optimize-towards-an-arbitrary-perfect-entangler" title="Permalink to this headline">¶</a></h2>
<p>The relevant property of a gate is often its entangling power, and the
requirement for a two-qubit gate in a universal set of gates is that it is a
“perfect entangler”. A perfect entangler can produce a maximally entangled
state from a separable input state. Since 85% of all two-qubit gates are
perfect entanglers <span id="id4">[<a class="reference internal" href="99_bibliography.html#id85" title="P. Watts, M. O'Connor, and J. Vala. Metric structure of the space of two-qubit gates, perfect entanglers and quantum control. Entropy  15, 1963 (2013). doi:10.3390/e15061963.">56</a>, <a class="reference internal" href="99_bibliography.html#id86" title="M. Musz, M. Kuś, and K. Życzkowski. Unitary quantum gates, perfect entanglers, and unistochastic maps. Phys. Rev. A  87, 022111 (2013). doi:10.1103/PhysRevA.87.022111.">57</a>]</span>, a functional that targets an
arbitrary perfect entangler <span id="id5">[<a class="reference internal" href="99_bibliography.html#id16" title="P. Watts, J. Vala, M. M. Müller, T. Calarco, K. B. Whaley, D. M. Reich, M. H. Goerz, and C. P. Koch. Optimizing for an arbitrary perfect entangler: I. Functionals. Phys. Rev. A  91, 062306 (2015). doi:10.1103/PhysRevA.91.062306.">28</a>, <a class="reference internal" href="99_bibliography.html#id17" title="M. H. Goerz, G. Gualdi, D. M. Reich, C. P. Koch, F. Motzoi, K. B. Whaley, J. Vala, M. M. Müller, S. Montangero, and T. Calarco. Optimizing for an arbitrary perfect entangler. II. Application. Phys. Rev. A  91, 062307 (2015). doi:10.1103/PhysRevA.91.062307.">29</a>]</span> solves the
control problem with the least constraints.</p>
<p>The optimization towards an arbitrary perfect entangler is closely related to
an optimization towards a point in the Weyl chamber
(<a class="reference internal" href="#howtolioptimization"><span class="std std-ref">How to optimize towards a two-qubit gate up to single-qubit corrections</span></a>): It turns out that
in the geometric representation of the <a class="reference external" href="https://weylchamber.readthedocs.io/en/latest/tutorial.html">Weyl chamber</a>, all the perfect
entanglers lie within a polyhedron, and we can simply minimize the geometric
distance to the surface of this polyhedron.</p>
<p>Use <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.gate_objectives" title="krotov.objectives.gate_objectives"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.objectives.gate_objectives()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">gate='PE'</span></code> in
order to construct a list of objectives suitable for an optimization using the
perfect entanglers functional <span id="id6">[<a class="reference internal" href="99_bibliography.html#id16" title="P. Watts, J. Vala, M. M. Müller, T. Calarco, K. B. Whaley, D. M. Reich, M. H. Goerz, and C. P. Koch. Optimizing for an arbitrary perfect entangler: I. Functionals. Phys. Rev. A  91, 062306 (2015). doi:10.1103/PhysRevA.91.062306.">28</a>, <a class="reference internal" href="99_bibliography.html#id17" title="M. H. Goerz, G. Gualdi, D. M. Reich, C. P. Koch, F. Motzoi, K. B. Whaley, J. Vala, M. M. Müller, S. Montangero, and T. Calarco. Optimizing for an arbitrary perfect entangler. II. Application. Phys. Rev. A  91, 062307 (2015). doi:10.1103/PhysRevA.91.062307.">29</a>]</span>.
This is illustrated in the <a class="reference internal" href="notebooks/07_example_PE.html"><span class="std std-ref">Optimization towards a Perfect Entangler</span></a>.</p>
<p>Again, the <cite>chi_constructor</cite> is available in the <a class="reference external" href="https://github.com/qucontrol/weylchamber"><code class="docutils literal notranslate"><span class="pre">weylchamber</span></code> package</a>.</p>
<p>Both the optimization towards a local equivalence class and an arbitrary perfect
entangler may require use of the second-order update equation, see
<a class="reference internal" href="07_krotovs_method.html#secondorderupdate"><span class="std std-ref">Second order update</span></a>.</p>
</div>
<div class="section" id="how-to-optimize-in-a-dissipative-system">
<span id="howtodissipativeoptimization"></span><h2>How to optimize in a dissipative system<a class="headerlink" href="#how-to-optimize-in-a-dissipative-system" title="Permalink to this headline">¶</a></h2>
<p>To optimize a dissipative system, it is sufficient to set an <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective" title="krotov.objectives.Objective"><code class="xref py py-class docutils literal notranslate"><span class="pre">Objective</span></code></a>
with a density matrix for the <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.initial_state" title="krotov.objectives.Objective.initial_state"><code class="xref py py-attr docutils literal notranslate"><span class="pre">initial_state</span></code></a> and
<a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.target" title="krotov.objectives.Objective.target"><code class="xref py py-attr docutils literal notranslate"><span class="pre">target</span></code></a>, and a Liouvillian in <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.H" title="krotov.objectives.Objective.H"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Objective.H</span></code></a>.
See the <a class="reference internal" href="notebooks/04_example_dissipative_qubit_reset.html"><span class="std std-ref">Optimization of Dissipative Qubit Reset</span></a> for an
example.</p>
<p>Instead of a Liouvillian, it is also possible to set <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.H" title="krotov.objectives.Objective.H"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Objective.H</span></code></a> to
the system Hamiltonian, and <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective.c_ops" title="krotov.objectives.Objective.c_ops"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Objective.c_ops</span></code></a> to the appropriate
Lindblad operators. However, it is generally much more efficient to use
<a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.liouvillian" title="krotov.objectives.liouvillian"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.objectives.liouvillian()</span></code></a> to convert a time-dependent Hamiltonian
and a list of Lindblad operators into a time-dependent Liouvillian. In either
case, the <cite>propagate</cite> routine passed to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>
must be aware of and compatible with the convention for the objectives.</p>
<p>Specifically for gate optimization, the routine
<a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.gate_objectives" title="krotov.objectives.gate_objectives"><code class="xref py py-func docutils literal notranslate"><span class="pre">gate_objectives()</span></code></a>
can be used to automatically set appropriate objectives for an optimization in
Liouville space. The parameter <cite>liouville_states_set</cite> indicates that the system
dynamics are in Liouville space and sets an appropriate choice of matrices that
track the optimization according to Ref. <span id="id7">[<a class="reference internal" href="99_bibliography.html#id19" title="M. H. Goerz, D. M. Reich, and C. P. Koch. Optimal control theory for a unitary operation under dissipative evolution. New J. Phys.  16, 055012 (2014). doi:10.1088/1367-2630/16/5/055012.">27</a>]</span>.
See the <a class="reference internal" href="notebooks/06_example_3states.html"><span class="std std-ref">Optimization of a Dissipative Quantum Gate</span></a> for an example.</p>
<p>For weak dissipation, it may also be possible to avoid the use of density
matrices altogether, and to instead use a non-Hermitian Hamiltonian. For example, you may
use the effective Hamiltonian from the MCWF method <span id="id8">[<a class="reference internal" href="99_bibliography.html#id20" title="M. B. Plenio and P. L. Knight. The quantum-jump approach to dissipative dynamics in quantum optics. Rev. Mod. Phys.  70, 101 (1998). doi:10.1103/RevModPhys.70.101.">58</a>]</span>,</p>
<div class="math notranslate nohighlight">
\[\Op{H}_{\text{eff}} = \Op{H} - \frac{i}{2} \sum_k \Op{L}_k^\dagger \Op{L}_k\,,\]</div>
<p>for the Hermitian Hamiltonian <span class="math notranslate nohighlight">\(\Op{H}\)</span> and the Lindblad operators
<span class="math notranslate nohighlight">\(\Op{L}_k\)</span>.  Propagating <span class="math notranslate nohighlight">\(\Op{H}_{\text{eff}}\)</span> (without quantum
jumps) will lead to a decay in the norm of the state corresponding to how much
dissipation the state is subjected to. Numerically, this will usually increase
the value of the optimization functional (that is, the error). Thus the
optimization can be pushed towards avoiding decoherence, without explicitly
performing the optimization in Liouville space. See the
<a class="reference internal" href="notebooks/03_example_lambda_system_rwa_non_hermitian.html"><span class="std std-ref">Optimization of a Dissipative State-to-State Transfer in a Lambda System</span></a> for an
example.</p>
</div>
<div class="section" id="how-to-optimize-for-robust-pulses">
<span id="howtorobustoptimization"></span><h2>How to optimize for robust pulses<a class="headerlink" href="#how-to-optimize-for-robust-pulses" title="Permalink to this headline">¶</a></h2>
<p>Control fields can be made robust with respect to variations in the
system by performing an “ensemble
optimization” <span id="id9">[<a class="reference internal" href="99_bibliography.html#id18" title="M. H. Goerz, E. J. Halperin, J. M. Aytac, C. P. Koch, and K. B. Whaley. Robustness of high-fidelity Rydberg gates with single-site addressability. Phys. Rev. A  90, 032329 (2014). doi:10.1103/PhysRevA.90.032329.">26</a>]</span>. The idea is to sample a
representative selection of possible system Hamiltonians, and to
optimize over an average of the entire ensemble. In the functional,
Eq. <a class="reference internal" href="07_krotovs_method.html#equation-functional">(1)</a>, respectively the update
Eq. <a class="reference internal" href="07_krotovs_method.html#equation-krotov-first-order-update">(12)</a>,
the index <span class="math notranslate nohighlight">\(k\)</span> now numbers not only the states, but also different
ensemble Hamiltonians: <span class="math notranslate nohighlight">\(\Op{H}(\{\epsilon_l(t)\}) \rightarrow \{\Op{H}_k(\{\epsilon_l(t)\})\}\)</span>.</p>
<p>The example considered in Ref. <span id="id10">[<a class="reference internal" href="99_bibliography.html#id18" title="M. H. Goerz, E. J. Halperin, J. M. Aytac, C. P. Koch, and K. B. Whaley. Robustness of high-fidelity Rydberg gates with single-site addressability. Phys. Rev. A  90, 032329 (2014). doi:10.1103/PhysRevA.90.032329.">26</a>]</span> is that
of a CPHASE two-qubit gate on trapped Rydberg atoms. Two classical
fluctuations contribute significantly to the gate error: deviations in
the pulse amplitude (<span class="math notranslate nohighlight">\(\Omega = 1\)</span> ideally), and fluctuations in
the energy of the Rydberg level (<span class="math notranslate nohighlight">\(\Delta_{\text{ryd}} = 0\)</span>
ideally). Starting from a set of objectives for the unperturbed system, see
<a class="reference internal" href="#howtogateoptimization"><span class="std std-ref">How to optimize towards a quantum gate</span></a>, <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.ensemble_objectives" title="krotov.objectives.ensemble_objectives"><code class="xref py py-func docutils literal notranslate"><span class="pre">ensemble_objectives()</span></code></a>
creates an extended set of objectives that duplicates the original objectives
once for each Hamiltonian from a set perturbed Hamiltonian
<span class="math notranslate nohighlight">\(\Op{H}(\Omega \neq 1, \Delta_{\text{ryd}} \neq 0)\)</span>.
As shown in Ref. <span id="id11">[<a class="reference internal" href="99_bibliography.html#id19" title="M. H. Goerz, D. M. Reich, and C. P. Koch. Optimal control theory for a unitary operation under dissipative evolution. New J. Phys.  16, 055012 (2014). doi:10.1088/1367-2630/16/5/055012.">27</a>]</span>, an optimization over the average of all
these objectives  results in controls that are robust over a wide range of
system perturbations.</p>
<p>A simpler example of an ensemble optimization is
<a class="reference internal" href="notebooks/08_example_ensemble.html"><span class="std std-ref">Ensemble Optimization for Robust Pulses</span></a>, which considers a state-to-state
transition in a Lamba-System with a dissipative intermediary state.</p>
</div>
<div class="section" id="how-to-apply-spectral-constraints">
<span id="howtospectralconstraints"></span><h2>How to apply spectral constraints<a class="headerlink" href="#how-to-apply-spectral-constraints" title="Permalink to this headline">¶</a></h2>
<p>In principle, Krotov’s method can include spectral constraints while
maintaining the guarantee for monotonic convergence <span id="id12">[<a class="reference internal" href="99_bibliography.html#id55" title="D. M. Reich, J. P. Palao, and C. P. Koch. Optimal control under spectral constraints: enforcing multi-photon absorption pathways. J. Mod. Opt.  61, 822 (2014). doi:10.1080/09500340.2013.844866.">59</a>]</span> .
However, the calculation of the pulse update with such spectral constraints
requires solving a Fredholm equation of the second kind, which has not yet been
implemented numerically. Thus, the <code class="docutils literal notranslate"><span class="pre">krotov</span></code> package does not support this
approach (and no such support is planned).</p>
<p>A “cheap” alternative that usually yields good results is to apply a spectral
filter to the optimized pulses after each iteration. The
<a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> function allows this via the
<cite>modify_params_after_iter</cite> argument.</p>
<p>For example, the following function restricts the spectrum of each pulse to a
given range:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_spectral_filter</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span> <span class="n">w0</span><span class="p">,</span> <span class="n">w1</span><span class="p">):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot;Spectral filter for real-valued pulses.</span>

<span class="sd">   The resulting filter function performs a Fast-Fourier-Transform (FFT) of</span>
<span class="sd">   each optimized pulse, and sets spectral components for angular</span>
<span class="sd">   frequencies below `w0` or above `w1` to zero. The filtered pulse is then</span>
<span class="sd">   the result of the inverse FFT, and multiplying again with the update</span>
<span class="sd">   shape for the pulse, to ensure that the filtered pulse still fulfills</span>
<span class="sd">   the required boundary conditions.</span>

<span class="sd">   Args:</span>
<span class="sd">       tlist (numpy.ndarray): Array of time grid values. All pulses must be</span>
<span class="sd">           defined on the intervals of this time grid</span>
<span class="sd">       w0 (float): The lowest allowed (angular) frequency</span>
<span class="sd">       w1 (float): The highest allowed (angular) frequency</span>

<span class="sd">   Returns:</span>
<span class="sd">       callable: A function that can be passed to</span>
<span class="sd">       `modify_params_after_iter` to apply the spectral filter.</span>
<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">tlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># assume equi-distant time grid</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># = len(pulse)</span>
    <span class="c1"># remember that pulses are defined on intervals of tlist</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">dt</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
    <span class="c1"># the normalization factor 2π means that w0 and w1 are angular</span>
    <span class="c1"># frequencies, corresponding directly to energies in the Hamiltonian</span>
    <span class="c1"># (ħ = 1).</span>

    <span class="n">flt</span> <span class="o">=</span> <span class="p">(</span><span class="n">w0</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">w1</span><span class="p">)</span>
    <span class="c1"># flt is the (boolean) filter array, equivalent to an array of values 0</span>
    <span class="c1"># and 1</span>

    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># same interface as an `info_hook` function</span>
        <span class="n">pulses</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;optimized_pulses&#39;</span><span class="p">]</span>
        <span class="n">shape_arrays</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shape_arrays&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pulses</span><span class="p">,</span> <span class="n">shape_arrays</span><span class="p">):</span>
            <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">pulse</span><span class="p">)</span>
            <span class="c1"># apply the filter by element-wise multiplication</span>
            <span class="n">spectrum</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">flt</span><span class="p">[:]</span>
            <span class="c1"># after the inverse fft, we should also multiply with the</span>
            <span class="c1"># update shape function. Otherwise, there is no guarantee that</span>
            <span class="c1"># the filtered pulse will be zero at t=0 and t=T (assuming that</span>
            <span class="c1"># is what the update shape is supposed to enforce). Also, it is</span>
            <span class="c1"># important that we overwrite `pulse` in-place (pulse[:] = ...)</span>
            <span class="n">pulse</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">shape</span>

    <span class="k">return</span> <span class="n">_filter</span>
</pre></div>
</div>
<p>This function is passed to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> as e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">modify_params_after_iter</span><span class="o">=</span><span class="n">apply_spectral_filter</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>to constrain the spectrum of the pulse to angular frequencies
<span class="math notranslate nohighlight">\(\omega \in [0, 7]\)</span>.
You may want to explore how such a filter behaves in the example of the
<a class="reference internal" href="notebooks/05_example_transmon_xgate.html"><span class="std std-ref">Optimization of an X-Gate for a Transmon Qubit</span></a>.</p>
<p>Modifying the optimized pulses “manually” through a
<code class="docutils literal notranslate"><span class="pre">modify_params_after_iter</span></code> function means that we lose all guarantees of
monotonic convergence. If the optimization with a spectral filter does not
converge, you should increase the value of <span class="math notranslate nohighlight">\(\lambda_a\)</span> in the <cite>pulse_options</cite>
that are passed to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>. A larger value of <span class="math notranslate nohighlight">\(\lambda_a\)</span>
results in smaller updates in each iteration. This should also translate into
the filter pulses being closer to the unfiltered pulses, increasing the
probability that the changes due to the filter do not undo the monotonic
convergence. You may also find that the optimization fails if the control
problem physically cannot be solved with controls in the desired spectral
range. Without a good physical intuition, trial and error may be
required.</p>
</div>
<div class="section" id="how-to-limit-the-amplitude-of-the-controls">
<h2>How to limit the amplitude of the controls<a class="headerlink" href="#how-to-limit-the-amplitude-of-the-controls" title="Permalink to this headline">¶</a></h2>
<p>Amplitude constraints on the control can be realized indirectly through
parametrization <span id="id13">[<a class="reference internal" href="99_bibliography.html#id53" title="M. M. Müller, D. M. Reich, M. Murphy, H. Yuan, J. Vala, K. B. Whaley, T. Calarco, and C. P. Koch. Optimizing entangling quantum gates for physical systems. Phys. Rev. A  84, 042315 (2011). doi:10.1103/PhysRevA.84.042315.">60</a>]</span>. For example, consider the physical
Hamiltonian <span class="math notranslate nohighlight">\(\Op{H} = \Op{H}_0 + \epsilon(t) \Op{H}_1\)</span>.</p>
<p>There are several possible parametrizations of <span class="math notranslate nohighlight">\(\epsilon(t)\)</span>
in terms of an unconstrained function <span class="math notranslate nohighlight">\(u(t)\)</span>:</p>
<ul>
<li><p>For <span class="math notranslate nohighlight">\(\epsilon(t) \ge 0\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\epsilon(t) = u^2(t)\]</div>
</div></blockquote>
</li>
<li><p>For <span class="math notranslate nohighlight">\(0 \le \epsilon(t) &lt; \epsilon_{\max}\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\epsilon(t) = \epsilon_{\max} \tanh^2\left(u(t)\right)\]</div>
</div></blockquote>
</li>
<li><p>For <span class="math notranslate nohighlight">\(\epsilon_{\min} &lt; \epsilon(t) &lt; \epsilon_{\max}\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\epsilon(t)
   = \frac{\epsilon_{\max} - \epsilon_{\min}}{2}
        \tanh\left(u(t)\right)
      + \frac{\epsilon_{\max} + \epsilon_{\min}}{2}\]</div>
</div></blockquote>
</li>
</ul>
<p>Krotov’s method can now calculate the update <span class="math notranslate nohighlight">\(\Delta u(t)\)</span> in each
iteration, and then <span class="math notranslate nohighlight">\(\Delta \epsilon(t)\)</span> via the above equations.</p>
<p>There is a caveat: In the update equation <a class="reference internal" href="07_krotovs_method.html#equation-krotov-first-order-update">(12)</a>, we
now have the term</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Bigg(
      \left.\frac{\partial \Op{H}}{\partial u}\right\vert_{{\scriptsize \begin{matrix}\phi^{(i+1)}(t)\\u^{(i+1)}(t)\end{matrix}}}
\Bigg)
=
\Bigg(
      \left.\frac{\partial \epsilon}{\partial u}\frac{\partial \Op{H}}{\partial \epsilon}\right\vert_{{\scriptsize \begin{matrix}\phi^{(i+1)}(t)\\u^{(i+1)}(t)\end{matrix}}}
\Bigg)\end{split}\]</div>
<p>on the right hand side. As the dependendence of <span class="math notranslate nohighlight">\(\epsilon(t)\)</span> on
<span class="math notranslate nohighlight">\(u(t)\)</span> is non-linear, we are left with a dependency on the unknown
updated parametrization <span class="math notranslate nohighlight">\(u^{(i+1)}(t)\)</span>. We resolve this by approximating
<span class="math notranslate nohighlight">\(u^{(i+1)}(t) \approx u^{(i)}(t)\)</span>, or equivalently <span class="math notranslate nohighlight">\(\Delta u(t) \ll
u(t)\)</span>, which can be enforced by choosing a sufficiently large value of
<span class="math notranslate nohighlight">\(\lambda_a\)</span> in the <cite>pulse_options</cite> that are passed to
<a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>.</p>
<p>Currently, the <code class="docutils literal notranslate"><span class="pre">krotov</span></code> package does not yet support parametrizations in the
above form, although this is a <a class="reference external" href="https://github.com/qucontrol/krotov/issues/23">planned feature</a>.
In the meantime, you could modify the control to fit within the desired
amplitude constaints in the same way as applying spectral constaints, see
<a class="reference internal" href="#howtospectralconstraints"><span class="std std-ref">How to apply spectral constraints</span></a>.</p>
</div>
<div class="section" id="how-to-parallelize-the-optimization">
<h2>How to parallelize the optimization<a class="headerlink" href="#how-to-parallelize-the-optimization" title="Permalink to this headline">¶</a></h2>
<p>Krotov’s method is inherently parallel across different objectives. See
<a class="reference internal" href="API/krotov.parallelization.html#module-krotov.parallelization" title="krotov.parallelization"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.parallelization</span></code></a>.</p>
<p>It is exceedingly important to ensure that you do not use any accidental nested
parallelization. The <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.26)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a> library is often eager to run in a
multi-threaded mode that does not combine well with the process-based
parallelization in <a class="reference internal" href="API/krotov.parallelization.html#module-krotov.parallelization" title="krotov.parallelization"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.parallelization</span></code></a>. See
<a class="reference internal" href="#howtolimitthreadpool"><span class="std std-ref">How to avoid over-subscribing the CPU when using parallelization</span></a>.</p>
</div>
<div class="section" id="how-to-avoid-over-subscribing-the-cpu-when-using-parallelization">
<span id="howtolimitthreadpool"></span><h2>How to avoid over-subscribing the CPU when using parallelization<a class="headerlink" href="#how-to-avoid-over-subscribing-the-cpu-when-using-parallelization" title="Permalink to this headline">¶</a></h2>
<p>A common caveat of parallelization is that the number of numerically intensive
threads or processes should not be larger than the number of CPUs on the
machine. “Oversubscribing” the CPUs can make a parallelized program run slower
by order of magnitudes compared to a serial program!</p>
<p>One consequence of this realization is that <em>nested parallelizaton</em> must be
tightly controlled: If your program used process-based parallelization (and
assuming each process can tax a CPU core at 100%), then you must prevent
multiple threads within each process. Depending on how they were compiled, some
of Python’s low-level numerical libraries (<a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.26)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a> in particular) are
eager to run in a multi-threaded mode, and it can be surprisingly difficult to
convince them not to do this. In general, you can
<a class="reference external" href="https://stackoverflow.com/questions/30791550/limit-number-of-threads-in-numpy/31622299#31622299">set environment variables to force low-level numerical code into single-threaded mode</a>:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">MKL_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">NUMEXPR_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">OMP_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>It may be a good idea to set these variables in your <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> (or the
equivalent for whatever shell you are using), and only change their values when
you specifically want to enable multi-threaded execution. You can sometimes set
these variables inside a Python script or notebook, but you must do so before
importing <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.26)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a>.</p>
<p>The <a class="reference external" href="https://github.com/joblib/threadpoolctl">threadpoolctl</a> python package is another alternative of eliminating
unexpected multi-threading. The functions in <a class="reference internal" href="API/krotov.parallelization.html#module-krotov.parallelization" title="krotov.parallelization"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.parallelization</span></code></a> use
this package internally to suppress low-level threads. For example, when using
<a class="reference internal" href="API/krotov.parallelization.html#krotov.parallelization.parallel_map" title="krotov.parallelization.parallel_map"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.parallelization.parallel_map()</span></code></a>, you can expected the execution to
be limited to the given <cite>num_cpus</cite>. Also, <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> by
defaults limits multi-threading, cf. the <cite>limit_thread_pool</cite> argument. Lastly,
<a class="reference internal" href="API/krotov.propagators.html#krotov.propagators.expm" title="krotov.propagators.expm"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.propagators.expm()</span></code></a> ensures that the matrix exponentiation is
calculated single-threadedly.</p>
<p>Always monitor your processes in a tool like <a class="reference external" href="https://hisham.hm/htop/">htop</a> to watch out for unexpected
CPU usage.</p>
</div>
<div class="section" id="how-to-prevent-losing-an-optimization-result">
<span id="howtostoreresult"></span><h2>How to prevent losing an optimization result<a class="headerlink" href="#how-to-prevent-losing-an-optimization-result" title="Permalink to this headline">¶</a></h2>
<p>Optimizations usually take several hundred to several thousand iterations to
fully converge. Thus, the <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> routine  may require
significant runtime (often multiple days for large problems). Once an
optimization has completed, you are strongly encouraged to store the result to
disk, using <a class="reference internal" href="API/krotov.result.html#krotov.result.Result.dump" title="krotov.result.Result.dump"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.dump()</span></code></a>.  You may also consider using
<a class="reference internal" href="API/krotov.convergence.html#krotov.convergence.dump_result" title="krotov.convergence.dump_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump_result()</span></code></a> during the <cite>check_convergence</cite> step to dump the current
state of the optimization to disk at regular intervals. This protects you from
losing work if the optimization is interrupted in any way, like an unexpected
crash.</p>
<p>In order to continue after such a crash, you can restore a <a class="reference internal" href="API/krotov.result.html#krotov.result.Result" title="krotov.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>
object containing the recent state of the optimization using
<a class="reference internal" href="API/krotov.result.html#krotov.result.Result.load" title="krotov.result.Result.load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Result.load()</span></code></a> (with the original <cite>objectives</cite> and <code class="docutils literal notranslate"><span class="pre">finalize=True</span></code> if
the dump file originates from <a class="reference internal" href="API/krotov.convergence.html#krotov.convergence.dump_result" title="krotov.convergence.dump_result"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump_result()</span></code></a>). You may then call
<a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> and pass the loaded <a class="reference internal" href="API/krotov.result.html#krotov.result.Result" title="krotov.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object as
<cite>continue_from</cite>.  The new optimization will start from the most recent
optimized controls as a guess, and continue to count iterations from the
previous result. See <a class="reference internal" href="#howtocontinueoptimization"><span class="std std-ref">How to continue from a previous optimization</span></a> for further details.</p>
</div>
<div class="section" id="how-to-continue-from-a-previous-optimization">
<span id="howtocontinueoptimization"></span><h2>How to continue from a previous optimization<a class="headerlink" href="#how-to-continue-from-a-previous-optimization" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="#howtostoreresult"><span class="std std-ref">How to prevent losing an optimization result</span></a> for how to continue from an optimization that ended
(crashed) prematurely.  Even when an optimization has completed normally, you
may still want to continue with further iterations – either because you find
that the original <cite>iter_stop</cite> was insufficient to reach full convergence, or
because you would like to modify some parameters, like the λₐ values for
each control. In this case, you can again call <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> and
pass the <a class="reference internal" href="API/krotov.result.html#krotov.result.Result" title="krotov.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object from the previous optimization as
<cite>continue_from</cite>. Note that while you are free to change the <cite>pulse_options</cite>
between the two optimization, the <cite>objectives</cite> must remain the same. The
functional (<cite>chi_constructor</cite>) and the <cite>info_hook</cite> should also remain the same
(otherwise, you may and up with inconsistencies in your <a class="reference internal" href="API/krotov.result.html#krotov.result.Result" title="krotov.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>). The
<a class="reference internal" href="API/krotov.result.html#krotov.result.Result" title="krotov.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object returned by the second optimization will include all
the data from the first optimization.</p>
</div>
<div class="section" id="how-to-maximize-numerical-efficiency">
<h2>How to maximize numerical efficiency<a class="headerlink" href="#how-to-maximize-numerical-efficiency" title="Permalink to this headline">¶</a></h2>
<p>For systems of non-trivial size, the main numerical effort should be in the
simulation of the system dynamics. Every iteration of Krotov’s method requires
a full backward propagation and a full forward propagation of the states associated with each
objective, see <a class="reference internal" href="API/krotov.propagators.html#module-krotov.propagators" title="krotov.propagators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.propagators</span></code></a>. Therefore, the best numerical
efficiency can be achieved by optimizing the performance of the <cite>propagator</cite>
that is passed to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>.</p>
<p>One possibility is to implement problem-specific propagators, such as
<a class="reference internal" href="API/krotov.propagators.html#krotov.propagators.DensityMatrixODEPropagator" title="krotov.propagators.DensityMatrixODEPropagator"><code class="xref py py-class docutils literal notranslate"><span class="pre">krotov.propagators.DensityMatrixODEPropagator</span></code></a>. Going further, you
might consider implementing the propagator with the help of lower-level instructions, e.g.,
by using <a class="reference external" href="https://cython.org">Cython</a>.</p>
</div>
<div class="section" id="how-to-deal-with-the-optimization-running-out-of-memory">
<h2>How to deal with the optimization running out of memory<a class="headerlink" href="#how-to-deal-with-the-optimization-running-out-of-memory" title="Permalink to this headline">¶</a></h2>
<p>Krotov’s method requires the storage of at least one set of propagated state
over the entire time grid, for each objective. For the second-order update
equation, up to three sets of stored states per objective may be required. In
particular for larger systems and dynamics in Liouville space, the memory
required for storing these states may be prohibitively expensive.</p>
<p>The <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> accepts a <cite>storage</cite> parameter
to which a constructor for an array-like container can be passed wherein the
propagated states will be stored. It is possible to pass custom out-of-memory
storage objects, such as <a class="reference external" href="http://docs.dask.org/en/latest/">Dask</a> arrays. This may carry a significant penalty in
runtime, however, as states will have to be read from disk, or across the
network.</p>
</div>
<div class="section" id="how-to-avoid-the-overhead-of-qutip-objects">
<h2>How to avoid the overhead of QuTiP objects<a class="headerlink" href="#how-to-avoid-the-overhead-of-qutip-objects" title="Permalink to this headline">¶</a></h2>
<p>If you know what you are doing, it is possible to set up an <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective" title="krotov.objectives.Objective"><code class="xref py py-class docutils literal notranslate"><span class="pre">Objective</span></code></a>
without any <a class="reference external" href="https://qutip.org/docs/4.5/apidoc/classes.html#qutip.Qobj" title="(in QuTiP: Quantum Toolbox in Python v4.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> instances, using arbitrary low-level objects
instead.  See the <a class="reference internal" href="notebooks/09_example_numpy.html"><span class="std std-ref">Optimization with numpy Arrays</span></a> for an example.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="notebooks/09_example_numpy.html" class="btn btn-neutral float-left" title="Optimization with numpy Arrays" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="11_other_methods.html" class="btn btn-neutral float-right" title="Other Optimization Methods" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Michael Goerz et al..
      <span class="lastupdated">Last updated on Jun 03, 2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>