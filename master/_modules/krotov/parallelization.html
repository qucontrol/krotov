<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>krotov.parallelization &mdash; Krotov 1.3.0+dev (341cb5c) documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d75fae25" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" href="../../_static/mycss.css" type="text/css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=2624feb1"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../_static/docs-versions-menu.js?v=3d6a1aea"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Krotov
          </a>
              <div class="version">
                1.3.0+dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../01_overview.html">Krotov Python Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../02_contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../03_authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../04_features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../05_history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../06_introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../07_krotovs_method.html">Krotovâ€™s Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../08_qutip_usage.html">Using Krotov with QuTiP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../09_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../10_howto.html">How-Tos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../11_other_methods.html">Other Optimization Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../12_related_software.html">Related Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../99_bibliography.html">References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../API/krotov.html">API of the Krotov package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Krotov</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          





















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>krotov.parallelization</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for krotov.parallelization</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Support routines for running the optimization in parallel across the</span>
<span class="sd">objectives.</span>

<span class="sd">The time-propagation that is the main numerical effort in an optimization with</span>
<span class="sd">Krotov&#39;s method can naturally be performed in parallel for the different</span>
<span class="sd">objectives. There are three time-propagations that happen inside</span>
<span class="sd">:func:`.optimize_pulses`:</span>

<span class="sd">1. A forward propagation of the :attr:`~.Objective.initial_state` of each</span>
<span class="sd">   objective under the initial guess pulse.</span>

<span class="sd">2. A backward propagation of the states $\ket{\chi_k}$ constructed by the</span>
<span class="sd">   `chi_constructor` routine that is passed to :func:`.optimize_pulses`, where</span>
<span class="sd">   the number of states is the same as the number of objectives.</span>

<span class="sd">3. A forward propagation of the :attr:`~.Objective.initial_state` of each</span>
<span class="sd">   objective under the optimized pulse in each iteration. This can only</span>
<span class="sd">   be parallelized *per time step*, as the propagated states from each time</span>
<span class="sd">   step collectively determine the pulse update for the next time step, which</span>
<span class="sd">   is then used for the next propagation step. (In this sense Krotov&#39;s method</span>
<span class="sd">   is &quot;sequential&quot;)</span>


<span class="sd">The :func:`.optimize_pulses` routine has a parameter `parallel_map` that can</span>
<span class="sd">receive a tuple of three &quot;map&quot; functions to enable parallelization,</span>
<span class="sd">corresponding to the three propagation listed above. If not given,</span>
<span class="sd">:func:`qutip.parallel.serial_map` is used for all three propagations, running</span>
<span class="sd">in serial. Any alternative &quot;map&quot; must have the same interface as</span>
<span class="sd">:func:`qutip.parallel.serial_map`.</span>

<span class="sd">It would be natural to assume that :func:`qutip.parallel.parallel_map`</span>
<span class="sd">respectively the slightly improved :func:`parallel_map` provided in this module</span>
<span class="sd">would be a good choice for parallel execution, using multiple CPUs on the same</span>
<span class="sd">machine.  However, this function is only a good choice for the propagation (1)</span>
<span class="sd">and (2): these run in parallel over the entire time grid without any</span>
<span class="sd">communication, and thus minimal overhead.  However, this is not true for the</span>
<span class="sd">propagation (3), which must synchronize after each time step. In that case, the</span>
<span class="sd">&quot;naive&quot; use of :func:`qutip.parallel.parallel_map` results in a communication</span>
<span class="sd">overhead that completely dominates the propagation, and actually makes the</span>
<span class="sd">optimization slower (potentially by more than an order of magnitude).</span>

<span class="sd">The function :func:`parallel_map_fw_prop_step` provided in this module is an</span>
<span class="sd">appropriate alternative implementation that uses long-running processes,</span>
<span class="sd">internal caching, and minimal inter-process communication to eliminate the</span>
<span class="sd">communication overhead as much as possible. However, the internal caching is</span>
<span class="sd">valid only under the assumption that the `propagate` function does not have</span>
<span class="sd">side effects.</span>

<span class="sd">In general,</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    parallel_map=(</span>
<span class="sd">        krotov.parallelization.parallel_map,</span>
<span class="sd">        krotov.parallelization.parallel_map,</span>
<span class="sd">        krotov.parallelization.parallel_map_fw_prop_step,</span>
<span class="sd">    )</span>

<span class="sd">is a decent choice for enabling parallelization for a typical multi-objective</span>
<span class="sd">optimization (but don&#39;t expect wonders: general pure-python parallelization is</span>
<span class="sd">an unsolved problem.)</span>

<span class="sd">You may implement your own &quot;map&quot; functions to exploit parallelization paradigms</span>
<span class="sd">other than Python&#39;s built-in :mod:`multiprocessing`, provided here. This</span>
<span class="sd">includes distributed propagation, e.g. through ipyparallel_ clusters. To write</span>
<span class="sd">your own `parallel_map` functions, review the source code of</span>
<span class="sd">:func:`.optimize_pulses` in detail.</span>

<span class="sd">In most cases, it will be difficult to obtain a linear speedup from</span>
<span class="sd">parallelization: even with carefully tuned manual interprocess communication,</span>
<span class="sd">the communication overhead can be substantial. For best results, it would be</span>
<span class="sd">necessary to use `parallel_map` functions implemented in Cython, where the GIL</span>
<span class="sd">can be released and the entire propagation (and storage of propagated states)</span>
<span class="sd">can be done in shared-memory with no overhead.</span>

<span class="sd">Also note that the overhead of multi-process parallelization is</span>
<span class="sd">platform-dependent. On Linux, subprocesses are &quot;forked&quot; which causes them to</span>
<span class="sd">inherit the current state of the parent process without any explicit (and</span>
<span class="sd">expensive) inter-process communication (IPC). On other platforms, most notably</span>
<span class="sd">Windows and the combination of macOS with Python 3.8, subprocesses are</span>
<span class="sd">&quot;spawned&quot; instead of &quot;forked&quot;: The subprocesses start from a clean slate, and</span>
<span class="sd">all objects must be transfered from the parent process via IPC. This is very</span>
<span class="sd">slow, and you should not expect to be able to achieve any speedup from</span>
<span class="sd">parallelization on such platforms.</span>

<span class="sd">Another caveat on platforms using &quot;spawn&quot; is that certain objects by default</span>
<span class="sd">cannot be transferred via IPC, due to limitations of the :mod:`pickle`</span>
<span class="sd">protocol. This affects :ref:`lambda` and functions defined in</span>
<span class="sd">Jupyter notebooks, in particular. The third-party :mod:`loky` library provides</span>
<span class="sd">an alternative implementation for multi-processes parallelization that does not</span>
<span class="sd">have these restrictions, but causes even more overhead.</span>

<span class="sd">You may attempt to use the various options to :func:`set_parallelization` in</span>
<span class="sd">order to find a combination of settings that minimizes the runtime in your</span>
<span class="sd">particular environment.</span>

<span class="sd">.. _ipyparallel: https://ipyparallel.readthedocs.io/en/latest/</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">qutip.parallel</span><span class="w"> </span><span class="kn">import</span> <span class="n">serial_map</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qutip.ui.progressbar</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseProgressBar</span><span class="p">,</span> <span class="n">TextProgressBar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">threadpoolctl</span><span class="w"> </span><span class="kn">import</span> <span class="n">threadpool_limits</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.conversions</span><span class="w"> </span><span class="kn">import</span> <span class="n">plug_in_pulse_values</span>


<span class="k">try</span><span class="p">:</span>

    <span class="kn">import</span><span class="w"> </span><span class="nn">loky</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">loky</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_reusable_executor</span> <span class="k">as</span> <span class="n">LokyReusableExecutor</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">loky.process_executor</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
        <span class="n">ProcessPoolExecutor</span> <span class="k">as</span> <span class="n">LokyProcessPoolExecutor</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">_HAS_LOKY</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>

    <span class="n">_HAS_LOKY</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">USE_LOKY</span> <span class="o">=</span> <span class="kc">False</span>
<span class="sd">&quot;&quot;&quot;Whether to use :mod:`loky` instead of :mod:`multiprocessing`.</span>

<span class="sd">Set by :func:`set_parallelization`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">USE_THREADPOOL_LIMITS</span> <span class="o">=</span> <span class="kc">True</span>
<span class="sd">&quot;&quot;&quot;Whether to limit the number of low-level BLAS/OpenMP threads.</span>

<span class="sd">When using multi-process parallelization, *nested parallelization* must be</span>
<span class="sd">avoided. That is, low-level numerical routines e.g. in :mod:`numpy` should not</span>
<span class="sd">be allowed to use multiple threads. This would lead to over-subscribing CPUs</span>
<span class="sd">and can slow down the entire program by orders of magnitude.</span>

<span class="sd">If True, threadpoolctl_ will be used internally to attempt to eliminate any</span>
<span class="sd">nested threads.</span>

<span class="sd">Set by :func:`set_parallelization`.</span>

<span class="sd">.. note::</span>

<span class="sd">    Alternatively (or in addition), you may want to consider setting the</span>
<span class="sd">    following environment variables in your shell:</span>

<span class="sd">    .. code-block:: shell</span>

<span class="sd">        export MKL_NUM_THREADS=1</span>
<span class="sd">        export NUMEXPR_NUM_THREADS=1</span>
<span class="sd">        export OMP_NUM_THREADS=1</span>

<span class="sd">.. _threadpoolctl: https://github.com/joblib/threadpoolctl</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;set_parallelization&#39;</span><span class="p">,</span>
    <span class="s1">&#39;parallel_map&#39;</span><span class="p">,</span>
    <span class="s1">&#39;serial_map&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Consumer&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FwPropStepTask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;parallel_map_fw_prop_step&#39;</span><span class="p">,</span>
<span class="p">]</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_no_threadpool_limits</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: nocover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;No-op replacement for :func:`threadpool_limits`.&quot;&quot;&quot;</span>
    <span class="c1"># this is just an empty context manager that does nothing.</span>
    <span class="k">yield</span> <span class="kc">None</span>


<div class="viewcode-block" id="set_parallelization">
<a class="viewcode-back" href="../../API/krotov.parallelization.html#krotov.parallelization.set_parallelization">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_parallelization</span><span class="p">(</span>
    <span class="n">use_loky</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">start_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">loky_pickler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">use_threadpool_limits</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>  <span class="c1"># pragma: nocover</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Configure multi-process parallelization.</span>

<span class="sd">    Args:</span>
<span class="sd">        use_loky (bool): Value for :obj:`USE_LOKY`.</span>
<span class="sd">        start_method (None or str): One of &#39;fork&#39;, &#39;spawn&#39;, and &#39;forkserver&#39;,</span>
<span class="sd">            see :func:`multiprocessing.set_start_method`. If ``use_loky=True``,</span>
<span class="sd">            also &#39;loky&#39; and &#39;loky_int_main&#39;, see :mod:`loky`. If None, a</span>
<span class="sd">            platform and version-dependent default will be chosen automatically</span>
<span class="sd">            (e.g., &#39;fork&#39; on Linux, &#39;spawn&#39; on Windows, &#39;loky&#39; if</span>
<span class="sd">            ``use_loky=True``)</span>
<span class="sd">        loky_pickler (None or str): Serialization module to use for</span>
<span class="sd">            :mod:`loky`. One of &#39;cloudpickle&#39;, &#39;pickle&#39;. This forces the</span>
<span class="sd">            serialization for *all* objects. The default value None chooses the</span>
<span class="sd">            serialization automatically depending of the type of object. Using</span>
<span class="sd">            &#39;cloudpickle&#39; is signficiantly slower than &#39;pickle&#39; (but &#39;pickle&#39;</span>
<span class="sd">            cannot serialize all objects, such as lambda functions or functions</span>
<span class="sd">            defined in a Jupyter notebook).</span>
<span class="sd">        use_threadpool_limits (bool): Value for :obj:`USE_THREADPOOL_LIMITS`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ImportError: if ``use_loky=True`` but :mod:`loky` is not installed.</span>

<span class="sd">    Note:</span>
<span class="sd">        When working in Jupyter notebooks on systems that use the &#39;spawn&#39;</span>
<span class="sd">        `start_method` (Windows, or macOS with Python &gt;= 3.8), you may have to</span>
<span class="sd">        use :mod:`loky` (``use_loky=True``). This will incur a signficiant</span>
<span class="sd">        increase in multi-processing overhead. Use Linux if you can.</span>

<span class="sd">    Warning:</span>
<span class="sd">        This function should only be called once per script/notebook, at its</span>
<span class="sd">        very beginning. The :obj:`USE_LOKY` and :obj:`USE_THREADPOOL_LIMITS`</span>
<span class="sd">        variables may be set at any time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">USE_LOKY</span>
    <span class="n">start_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fork&#39;</span><span class="p">,</span> <span class="s1">&#39;spawn&#39;</span><span class="p">,</span> <span class="s1">&#39;forkserver&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">use_loky</span><span class="p">:</span>
        <span class="n">start_methods</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;loky&#39;</span><span class="p">,</span> <span class="s1">&#39;loky_int_main&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">start_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">start_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start_method not in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_methods</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">use_loky</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_HAS_LOKY</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;The loky library is not installed.&quot;</span><span class="p">)</span>
        <span class="n">USE_LOKY</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">loky</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="n">start_method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loky_pickler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loky</span><span class="o">.</span><span class="n">set_loky_pickler</span><span class="p">(</span><span class="n">loky_pickler</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">multiprocessing</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="n">start_method</span><span class="p">)</span></div>



<div class="viewcode-block" id="parallel_map">
<a class="viewcode-back" href="../../API/krotov.parallelization.html#krotov.parallelization.parallel_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parallel_map</span><span class="p">(</span>
    <span class="n">task</span><span class="p">,</span>
    <span class="n">values</span><span class="p">,</span>
    <span class="n">task_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">task_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_cpus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">progress_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map function `task` onto `values`, in parallel.</span>

<span class="sd">    This function&#39;s interface is identical to</span>
<span class="sd">    :func:`qutip.parallel.parallel_map` as of QuTiP 4.5.0, but has the option</span>
<span class="sd">    of using :mod:`loky` as a backend (see :func:`set_parallelization`). It</span>
<span class="sd">    also eliminates internal threads, according to</span>
<span class="sd">    :obj:`USE_THREADPOOL_LIMITS`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: if QuTiP&#39;s parallel_map catches up, we can remove this function,</span>
    <span class="c1"># and put QuTiP&#39;s parallel_map into __all__ to maintain krotov&#39;s interface.</span>
    <span class="k">if</span> <span class="n">task_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">task_args</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">if</span> <span class="n">task_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">task_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">num_cpus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_cpus</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">progress_bar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">BaseProgressBar</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">progress_bar</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">TextProgressBar</span><span class="p">()</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="n">nfinished</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_progress_bar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">nfinished</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nfinished</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">USE_LOKY</span><span class="p">:</span>
        <span class="n">Executor</span> <span class="o">=</span> <span class="n">LokyReusableExecutor</span>
        <span class="k">if</span> <span class="n">USE_THREADPOOL_LIMITS</span><span class="p">:</span>
            <span class="n">Executor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">LokyReusableExecutor</span><span class="p">,</span>
                <span class="n">initializer</span><span class="o">=</span><span class="n">_process_threadpool_limits_initializier</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Executor</span> <span class="o">=</span> <span class="n">ProcessPoolExecutor</span>

    <span class="n">_threadpool_limits</span> <span class="o">=</span> <span class="n">_no_threadpool_limits</span>
    <span class="k">if</span> <span class="n">USE_THREADPOOL_LIMITS</span><span class="p">:</span>
        <span class="n">_threadpool_limits</span> <span class="o">=</span> <span class="n">threadpool_limits</span>

    <span class="k">with</span> <span class="n">_threadpool_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">Executor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_cpus</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">task_args</span><span class="p">)</span>
                    <span class="n">job</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">_update_progress_bar</span><span class="p">)</span>
                    <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_process_threadpool_limits_initializier</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initializer for settings threadpool limits.</span>

<span class="sd">    This is an initializer for :mod:`loky` Executors that deactivates threads</span>
<span class="sd">    in the spawned sub-processes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>  <span class="c1"># required for loky&#39;s autodetection</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">threadpoolctl</span><span class="w"> </span><span class="kn">import</span> <span class="n">threadpool_limits</span>

    <span class="n">threadpool_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="Consumer">
<a class="viewcode-back" href="../../API/krotov.parallelization.html#krotov.parallelization.Consumer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Consumer</span><span class="p">(</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A process-based task consumer.</span>

<span class="sd">    This is for internal use in :func:`parallel_map_fw_prop_step`.</span>

<span class="sd">    Args:</span>
<span class="sd">        task_queue (multiprocessing.JoinableQueue): A queue from which to read</span>
<span class="sd">            tasks.</span>
<span class="sd">        result_queue (multiprocessing.Queue): A queue where to put the results</span>
<span class="sd">            of a task</span>
<span class="sd">        data: cached (in-process) data that will be passed to each task</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_queue</span><span class="p">,</span> <span class="n">result_queue</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task_queue</span> <span class="o">=</span> <span class="n">task_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_queue</span> <span class="o">=</span> <span class="n">result_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

<div class="viewcode-block" id="Consumer.run">
<a class="viewcode-back" href="../../API/krotov.parallelization.html#krotov.parallelization.Consumer.run">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute all tasks on the `task_queue`.</span>

<span class="sd">        Each task must be a callable that takes `data` as its only argument.</span>
<span class="sd">        The return value of the task will be put on the `result_queue`. A None</span>
<span class="sd">        value on the `task_queue` acts as a &quot;poison pill&quot;, causing the</span>
<span class="sd">        :class:`Consumer` process to shut down.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_threadpool_limits</span> <span class="o">=</span> <span class="n">_no_threadpool_limits</span>
        <span class="k">if</span> <span class="n">USE_THREADPOOL_LIMITS</span><span class="p">:</span>
            <span class="n">_threadpool_limits</span> <span class="o">=</span> <span class="n">threadpool_limits</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">next_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">next_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Poison pill means shutdown</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">task_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
                <span class="k">break</span>
            <span class="k">with</span> <span class="n">_threadpool_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">answer</span> <span class="o">=</span> <span class="n">next_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">task_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FwPropStepTask">
<a class="viewcode-back" href="../../API/krotov.parallelization.html#krotov.parallelization.FwPropStepTask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FwPropStepTask</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A task that performs a single forward-propagation step.</span>

<span class="sd">    The task object is a callable, receiving the single tuple of the same</span>
<span class="sd">    form as `task_args` in :func:`parallel_map_fw_prop_step` as input. This</span>
<span class="sd">    `data` is internally cached by the :class:`Consumer` that will execute</span>
<span class="sd">    the task.</span>

<span class="sd">    This is for internal use in :func:`parallel_map_fw_prop_step`.</span>

<span class="sd">    Args:</span>
<span class="sd">        i_state (int): The index of the state to propagation. That is, the</span>
<span class="sd">            index of the objective from whose :attr:`~.Objective.initial_state`</span>
<span class="sd">            the propagation started</span>
<span class="sd">        pulse_vals (list[float]): the values of the pulses at `time_index` to</span>
<span class="sd">            use.</span>
<span class="sd">        time_index (int): the index of the interval on the time grid covered by</span>
<span class="sd">            the propagation step</span>

<span class="sd">    The passed arguments update the internal state (`data`) of the</span>
<span class="sd">    :class:`Consumer` executing the task; they are the minimal information that</span>
<span class="sd">    must be passed via inter-process communication to enable the forward</span>
<span class="sd">    propagation (assuming `propagate` in :func:`.optimize_pulses` has no</span>
<span class="sd">    side-effects)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_state</span><span class="p">,</span> <span class="n">pulse_vals</span><span class="p">,</span> <span class="n">time_index</span><span class="p">):</span>
        <span class="c1"># The task object itself gets send to the Consumer via IPC (pickling).</span>
        <span class="c1"># Since this is only a few scalar values, we largely avoid</span>
        <span class="c1"># communication overhead</span>
        <span class="c1"># warnings.warn(</span>
        <span class="c1">#    &quot;FwPropStepTask is deprecated and will be removed in version 2.0&quot;,</span>
        <span class="c1">#    warnings.DeprecationWarning,</span>
        <span class="c1"># )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_state</span> <span class="o">=</span> <span class="n">i_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pulse_vals</span> <span class="o">=</span> <span class="n">pulse_vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span> <span class="o">=</span> <span class="n">time_index</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="p">(</span>
            <span class="n">states</span><span class="p">,</span>
            <span class="n">objectives</span><span class="p">,</span>
            <span class="n">pulses</span><span class="p">,</span>
            <span class="n">pulses_mapping</span><span class="p">,</span>
            <span class="n">tlist</span><span class="p">,</span>
            <span class="n">_</span><span class="p">,</span>  <span class="c1"># time_index</span>
            <span class="n">propagators</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># the data is passed by the Consumer, and is cached locally inside of</span>
        <span class="c1"># each process. Thus, it does not contribute to the IPC communication</span>
        <span class="c1"># overhead</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_index</span>
        <span class="n">pulse_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulse_vals</span>
        <span class="n">i_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_state</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="n">pulse_val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pulses</span><span class="p">,</span> <span class="n">pulse_vals</span><span class="p">):</span>
            <span class="n">pulse</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pulse_val</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="n">pulse_val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pulses</span><span class="p">,</span> <span class="n">pulse_vals</span><span class="p">):</span>
            <span class="n">pulse</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pulse_val</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">pulses_mapping</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">objectives</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">plug_in_pulse_values</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">pulses</span><span class="p">,</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_index</span><span class="p">)</span>
        <span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">plug_in_pulse_values</span><span class="p">(</span><span class="n">c_op</span><span class="p">,</span> <span class="n">pulses</span><span class="p">,</span> <span class="n">mapping</span><span class="p">[</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">time_index</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">c_op</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">c_ops</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">tlist</span><span class="p">[</span><span class="n">time_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tlist</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span>
        <span class="n">states</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span> <span class="o">=</span> <span class="n">propagators</span><span class="p">[</span><span class="n">i_state</span><span class="p">](</span><span class="n">H</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">)</span>
        <span class="c1"># While there is no significant IPC-communication overhead associated</span>
        <span class="c1"># with the *input* of the task, the resulting state returned here still</span>
        <span class="c1"># must go through the `result_queue` of the Consumer. This is the main</span>
        <span class="c1"># bottleneck of this implementation.</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span></div>



<div class="viewcode-block" id="parallel_map_fw_prop_step">
<a class="viewcode-back" href="../../API/krotov.parallelization.html#krotov.parallelization.parallel_map_fw_prop_step">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parallel_map_fw_prop_step</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">task_args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;`parallel_map` function for the forward-propagation by one time step.</span>

<span class="sd">    Args:</span>
<span class="sd">        shared: A global object to which we can attach attributes for sharing</span>
<span class="sd">            data between different calls to :func:`parallel_map_fw_prop_step`,</span>
<span class="sd">            allowing us to have long-running :class:`Consumer` processes,</span>
<span class="sd">            avoiding process-management overhead.</span>
<span class="sd">            This happens to be a callable (the original internal routine for</span>
<span class="sd">            performing a forward-propagation), but here, it is (ab-)used as a</span>
<span class="sd">            storage object only.</span>
<span class="sd">        values (list): a list 0..(N-1) where N is the number of objectives</span>
<span class="sd">        task_args (tuple): A tuple of 7 components:</span>

<span class="sd">            1. A list of states to propagate, one for each objective.</span>
<span class="sd">            2. The list of objectives</span>
<span class="sd">            3. The list of optimized pulses (updated up to `time_index`)</span>
<span class="sd">            4. The &quot;pulses mapping&quot;, cf :func:`.extract_controls_mapping`</span>
<span class="sd">            5. The list of time grid points</span>
<span class="sd">            6. The index of the interval on the time grid over which to</span>
<span class="sd">               propagate</span>
<span class="sd">            7. A list of `propagate` callables, as passed to</span>
<span class="sd">               :func:`.optimize_pulses`.  The propagators must not have</span>
<span class="sd">               side-effects in order for :func:`parallel_map_fw_prop_step` to</span>
<span class="sd">               work correctly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># `shared` is the original task function</span>
    <span class="c1"># (krotov.optimize._forward_propagation_step), but here we abuse it</span>
    <span class="c1"># as a shared namespace, between calls to `my_map`, by setting custom</span>
    <span class="c1"># data attributes on it</span>
    <span class="k">if</span> <span class="n">USE_LOKY</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_parallel_map_fw_prop_step_loky</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">task_args</span><span class="p">)</span>
    <span class="n">tlist</span> <span class="o">=</span> <span class="n">task_args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">pulses</span> <span class="o">=</span> <span class="n">task_args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">time_index</span> <span class="o">=</span> <span class="n">task_args</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">time_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># set up a Consumer process that stays active for the entire</span>
        <span class="c1"># propagation (multiple calls of `parallel_map_fw_prop_step`)</span>
        <span class="n">shared</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">JoinableQueue</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">shared</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">shared</span><span class="o">.</span><span class="n">consumers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Consumer</span><span class="p">(</span><span class="n">shared</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">shared</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">task_args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">consumer</span> <span class="ow">in</span> <span class="n">shared</span><span class="o">.</span><span class="n">consumers</span><span class="p">:</span>
            <span class="n">consumer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c1"># Assign tasks</span>
    <span class="n">pulse_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulses</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">time_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pulses</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="n">shared</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span><span class="o">.</span><span class="n">put</span><span class="p">(</span>
            <span class="n">FwPropStepTask</span><span class="p">(</span><span class="n">i_state</span><span class="p">,</span> <span class="n">pulse_vals</span><span class="p">,</span> <span class="n">time_index</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="n">shared</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># wait to finish</span>
    <span class="c1"># collect results</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">shared</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">time_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># end of time grid</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">shared</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># add poison pill</span>
            <span class="n">shared</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># wait to finish</span>
    <span class="k">return</span> <span class="n">res</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_parallel_map_fw_prop_step_loky</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">task_args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Loky-based implementation of :func:`parallel_map_fw_prop_step`.&quot;&quot;&quot;</span>
    <span class="n">tlist</span> <span class="o">=</span> <span class="n">task_args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">pulses</span> <span class="o">=</span> <span class="n">task_args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">time_index</span> <span class="o">=</span> <span class="n">task_args</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">time_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># we only send the full task_args through IPC once, for the first time</span>
        <span class="c1"># step. Subsequent time steps will reuse the data</span>
        <span class="n">shared</span><span class="o">.</span><span class="n">executors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">LokyProcessPoolExecutor</span><span class="p">(</span>
                <span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">initializer</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span>
                    <span class="n">_pmfw_initializer</span><span class="p">,</span> <span class="n">limit_thread_pool</span><span class="o">=</span><span class="n">USE_THREADPOOL_LIMITS</span>
                <span class="p">),</span>
                <span class="n">initargs</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">state_index</span><span class="p">,</span>
                    <span class="n">task_args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">state_index</span><span class="p">],</span>  <span class="c1"># initial_state</span>
                    <span class="n">task_args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">state_index</span><span class="p">],</span>  <span class="c1"># objective</span>
                    <span class="n">task_args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># pulses</span>
                    <span class="n">task_args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>  <span class="c1"># pulses_mapping</span>
                    <span class="n">task_args</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>  <span class="c1"># tlist</span>
                    <span class="n">task_args</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">state_index</span><span class="p">],</span>  <span class="c1"># propagator</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">state_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="n">pulse_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">pulses</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">time_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pulses</span><span class="p">))]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i_state</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">shared</span><span class="o">.</span><span class="n">executors</span><span class="p">[</span><span class="n">i_state</span><span class="p">]</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                <span class="n">_pmfw_forward_prop_step</span><span class="p">,</span> <span class="n">pulse_vals</span><span class="p">,</span> <span class="n">time_index</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">time_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># end of time grid</span>
        <span class="k">del</span> <span class="n">shared</span><span class="o">.</span><span class="n">executors</span>

    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pmfw_initializer</span><span class="p">(</span>
    <span class="n">state_index</span><span class="p">,</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">objective</span><span class="p">,</span>
    <span class="n">pulses</span><span class="p">,</span>
    <span class="n">pulses_mapping</span><span class="p">,</span>
    <span class="n">tlist</span><span class="p">,</span>
    <span class="n">propagator</span><span class="p">,</span>
    <span class="n">limit_thread_pool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy `task_args` into a process-local global variable.&quot;&quot;&quot;</span>
    <span class="c1"># for internal use in _parallel_map_fw_prop_step_loky</span>
    <span class="k">global</span> <span class="n">_pmfw_data</span>

    <span class="k">if</span> <span class="n">limit_thread_pool</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>  <span class="c1"># required for loky&#39;s autodetection</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">threadpoolctl</span><span class="w"> </span><span class="kn">import</span> <span class="n">threadpool_limits</span>

        <span class="n">threadpool_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">_pmfw_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">,</span>
        <span class="n">state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="n">objective</span><span class="o">=</span><span class="n">objective</span><span class="p">,</span>
        <span class="n">pulses</span><span class="o">=</span><span class="n">pulses</span><span class="p">,</span>
        <span class="n">pulses_mapping</span><span class="o">=</span><span class="n">pulses_mapping</span><span class="p">,</span>
        <span class="n">tlist</span><span class="o">=</span><span class="n">tlist</span><span class="p">,</span>
        <span class="n">propagator</span><span class="o">=</span><span class="n">propagator</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pmfw_forward_prop_step</span><span class="p">(</span><span class="n">pulse_vals</span><span class="p">,</span> <span class="n">time_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Propagate a single step, with minimal non-local data.</span>

<span class="sd">    Most of the data taken from the process-local global storage set by the</span>
<span class="sd">    initializer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># for internal use in _parallel_map_fw_prop_step_loky</span>
    <span class="k">global</span> <span class="n">_pmfw_data</span>
    <span class="n">_threadpool_limits</span> <span class="o">=</span> <span class="n">_no_threadpool_limits</span>
    <span class="k">if</span> <span class="n">USE_THREADPOOL_LIMITS</span><span class="p">:</span>
        <span class="n">_threadpool_limits</span> <span class="o">=</span> <span class="n">threadpool_limits</span>
    <span class="n">i_state</span> <span class="o">=</span> <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;state_index&#39;</span><span class="p">]</span>
    <span class="n">pulses</span> <span class="o">=</span> <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;pulses&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pulse</span><span class="p">,</span> <span class="n">pulse_val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pulses</span><span class="p">,</span> <span class="n">pulse_vals</span><span class="p">):</span>
        <span class="n">pulse</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pulse_val</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;pulses_mapping&#39;</span><span class="p">][</span><span class="n">i_state</span><span class="p">]</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;objective&#39;</span><span class="p">]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">plug_in_pulse_values</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">pulses</span><span class="p">,</span> <span class="n">mapping</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_index</span><span class="p">)</span>
    <span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">plug_in_pulse_values</span><span class="p">(</span><span class="n">c_op</span><span class="p">,</span> <span class="n">pulses</span><span class="p">,</span> <span class="n">mapping</span><span class="p">[</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">time_index</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">c_op</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">c_ops</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">tlist</span> <span class="o">=</span> <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;tlist&#39;</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">tlist</span><span class="p">[</span><span class="n">time_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tlist</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span>
    <span class="k">with</span> <span class="n">_threadpool_limits</span><span class="p">(</span><span class="n">limits</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;propagator&#39;</span><span class="p">](</span>
            <span class="n">H</span><span class="p">,</span> <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c_ops</span>
        <span class="p">)</span>
    <span class="n">_pmfw_data</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_state</span>
    <span class="k">return</span> <span class="n">next_state</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Michael Goerz et al..
      <span class="lastupdated">Last updated on Feb 25, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>