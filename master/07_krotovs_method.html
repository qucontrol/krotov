

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Krotov’s Method &mdash; Krotov 1.0.0+dev (3c3d982) documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script type="text/javascript" src="_static/version-menu.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/SVG"], "TeX": {"extensions": ["AMSmath.js", "AMSsymbols.js"], "Macros": {"tr": ["{\\operatorname{tr}}", 0], "diag": ["{\\operatorname{diag}}", 0], "abs": ["{\\operatorname{abs}}", 0], "pop": ["{\\operatorname{pop}}", 0], "ee": ["{\\text{e}}", 0], "ii": ["{\\text{i}}", 0], "aux": ["{\\text{aux}}", 0], "opt": ["{\\text{opt}}", 0], "tgt": ["{\\text{tgt}}", 0], "init": ["{\\text{init}}", 0], "lab": ["{\\text{lab}}", 0], "rwa": ["{\\text{rwa}}", 0], "bra": ["{\\langle#1\\vert}", 1], "ket": ["{\\vert#1\\rangle}", 1], "Bra": ["{\\left\\langle#1\\right\\vert}", 1], "Braket": ["{\\left\\langle #1\\vphantom{#2} \\mid #2\\vphantom{#1}\\right\\rangle}", 2], "ketbra": ["{\\vert#1\\rangle\\!\\langle#2\\vert}", 2], "Ket": ["{\\left\\vert#1\\right\\rangle}", 1], "mat": ["{\\mathbf{#1}}", 1], "op": ["{\\hat{#1}}", 1], "Op": ["{\\hat{#1}}", 1], "dd": ["{\\,\\text{d}}", 0], "daggered": ["{^{\\dagger}}", 0], "transposed": ["{^{\\text{T}}}", 0], "Liouville": ["{\\mathcal{L}}", 0], "DynMap": ["{\\mathcal{E}}", 0], "identity": ["{\\mathbf{1}}", 0], "Norm": ["{\\left\\lVert#1\\right\\rVert}", 1], "norm": ["{\\lVert#1\\rVert}", 1], "Abs": ["{\\left\\vert#1\\right\\vert}", 1], "avg": ["{\\langle#1\\rangle}", 1], "Avg": ["{\\left\\langle#1\\right\\rangle}", 1], "AbsSq": ["{\\left\\vert#1\\right\\vert^2}", 1], "Re": ["{\\operatorname{Re}}", 0], "Im": ["{\\operatorname{Im}}", 0], "Real": ["{\\mathbb{R}}", 0], "Complex": ["{\\mathbb{C}}", 0], "Integer": ["{\\mathbb{N}}", 0]}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/mycss.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Using Krotov with QuTiP" href="08_qutip_usage.html" />
    <link rel="prev" title="Introduction" href="06_introduction.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Krotov
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0+dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_overview.html">Krotov Python Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Krotov’s Method</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-quantum-control-problem">The quantum control problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimization-functional">Optimization functional</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterative-control-update">Iterative control update</a></li>
<li class="toctree-l2"><a class="reference internal" href="#first-order-update">First order update</a></li>
<li class="toctree-l2"><a class="reference internal" href="#second-order-update">Second order update</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-discretization">Time discretization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pseudocode">Pseudocode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#choice-of-a">Choice of λₐ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#complex-controls-and-the-rwa">Complex controls and the RWA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimization-in-liouville-space">Optimization in Liouville space</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="08_qutip_usage.html">Using Krotov with QuTiP</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_howto.html">How-Tos</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_other_methods.html">Other Optimization Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_related_software.html">Related Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="99_bibliography.html">References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="API/krotov.html">API of the Krotov package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Krotov</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          





















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Krotov’s Method</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="krotovs-method">
<span id="krotovsmethod"></span><h1>Krotov’s Method<a class="headerlink" href="#krotovs-method" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-quantum-control-problem">
<h2>The quantum control problem<a class="headerlink" href="#the-quantum-control-problem" title="Permalink to this headline">¶</a></h2>
<p>Quantum optimal control methods formalize the problem of finding
“control fields” that steer the time evolution of a quantum system in
some desired way. For closed systems, described by a Hilbert space state
<span class="math notranslate nohighlight">\(\ket{\Psi(t)}\)</span>, this time evolution is given by the Schrödinger
equation,</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial t} \Ket{\Psi(t)}
  = -\frac{\mathrm{i}}{\hbar} \Op{H}(t)\Ket{\Psi(t)}\,,\]</div>
<p>where the Hamiltonian <span class="math notranslate nohighlight">\(\Op{H}(t)\)</span> depends on one or more control
fields <span class="math notranslate nohighlight">\(\{\epsilon_l(t)\}\)</span>. We often assume the Hamiltonian to be
linear in the controls,</p>
<div class="math notranslate nohighlight">
\[\Op{H}(t)
  = \Op{H}_0 + \epsilon_1(t) \Op{H}_1 + \epsilon_2(t) \Op{H}_2 + \dots\]</div>
<p>but non-linear couplings may also occur, for example when considering
non-resonant multi-photon transitions. For open quantum systems
described by a density matrix <span class="math notranslate nohighlight">\(\hat{\rho}(t)\)</span>, the
Liouville-von-Neumann equation</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial t} \hat{\rho}(t)
= \frac{1}{\hbar} \Liouville(t) \hat{\rho}(t)\]</div>
<p>replaces the Schrödinger equation, with the (non-Hermitian) Liouvillian
<span class="math notranslate nohighlight">\(\Liouville(t)\)</span>.
The most direct example of a control problem is a state-to-state transition.
The objective is for a known quantum state <span class="math notranslate nohighlight">\(\ket{\phi}\)</span> at time
zero to evolve to a specific target state <span class="math notranslate nohighlight">\(\ket{\phi^\tgt}\)</span> at
final time <span class="math notranslate nohighlight">\(T\)</span>, controlling, e.g. a chemical
reaction <a class="bibtex reference internal" href="99_bibliography.html#tannorjcp1985" id="id1">[37]</a>.
Another example is the
realization of quantum gates, the building blocks of a quantum computer.
In this case, the states forming a computational basis must transform
according to a unitary transformation <a class="bibtex reference internal" href="99_bibliography.html#nielsenchuang" id="id2">[2]</a>,
see <a class="reference internal" href="10_howto.html#howtogateoptimization"><span class="std std-ref">How to optimize towards a quantum gate</span></a>. Thus, the
control problem involves not just the time evolution of a single state,
but a set of states <span class="math notranslate nohighlight">\(\{\ket{\phi_k(t)}\}\)</span>. Generalizing even
further, each state <span class="math notranslate nohighlight">\(\ket{\phi_k(t)}\)</span> in the control problem may
evolve under a different Hamiltonian
<span class="math notranslate nohighlight">\(\Op{H}_k(\{\epsilon_l(t)\})\)</span>, see <a class="reference internal" href="10_howto.html#howtorobustoptimization"><span class="std std-ref">How to optimize for robust pulses</span></a>.</p>
<p>Physically, the control fields <span class="math notranslate nohighlight">\(\{\epsilon_l(t)\}\)</span> might be the
amplitudes of a laser pulse for the control of molecular systems or
trapped atom/ion quantum computers, radio-frequency fields for nuclear
magnetic resonance, or microwave fields for superconducting circuits.
When there are multiple independent controls <span class="math notranslate nohighlight">\(\{\epsilon_l(t)\}\)</span>
involved in the dynamics, these may correspond e.g., to different color
lasers used in the excitation of a Rydberg atom, or different
polarization components of an electric field.</p>
<p>The quantum control methods build on a rich field of classical control
theory <a class="bibtex reference internal" href="99_bibliography.html#bellmanbook" id="id3">[38]</a><a class="bibtex reference internal" href="99_bibliography.html#pontryaginbook" id="id4">[39]</a>. This includes
Krotov’s method <a class="bibtex reference internal" href="99_bibliography.html#krotovec1983" id="id5">[40]</a><a class="bibtex reference internal" href="99_bibliography.html#krotovcc1988" id="id6">[41]</a><a class="bibtex reference internal" href="99_bibliography.html#krotov-book" id="id7">[42]</a><a class="bibtex reference internal" href="99_bibliography.html#konnovarc99" id="id8">[43]</a>,
which was originally formulated to optimize the soft landing of a
spacecraft from orbit to the surface of a planet, before being applied
to quantum mechanical
problems <a class="bibtex reference internal" href="99_bibliography.html#tannor92" id="id9">[5]</a><a class="bibtex reference internal" href="99_bibliography.html#somloicp1993" id="id10">[44]</a><a class="bibtex reference internal" href="99_bibliography.html#bartanajcp1997" id="id11">[45]</a><a class="bibtex reference internal" href="99_bibliography.html#sklarzpra2002" id="id12">[46]</a><a class="bibtex reference internal" href="99_bibliography.html#reichjcp12" id="id13">[22]</a>.
Fundamentally, they rely on the variational principle, that is, the
minimization of a functional
<span class="math notranslate nohighlight">\(J[\{\ket{\phi_k^{(i)}(t)}\}, \{\epsilon_l^{(i)}(t)\}]\)</span> that
includes any required constraints via Lagrange multipliers. The
condition for minimizing <span class="math notranslate nohighlight">\(J\)</span> is then
<span class="math notranslate nohighlight">\(\nabla_{\phi_k, \epsilon_l} J = 0\)</span>. In rare cases, the
variational calculus can be solved in closed form, based on Pontryagin’s
maximum principle <a class="bibtex reference internal" href="99_bibliography.html#pontryaginbook" id="id14">[39]</a>. Numerical methods
are required in any other case. These start from an initial guess
control (or set of guess controls, if there are multiple controls), and
calculate an update to these controls that will decrease the value of
the functional. The updated controls then become the guess for the next
iteration of the algorithm, until the value of the functional is
sufficiently small, or convergence is reached.</p>
</div>
<div class="section" id="optimization-functional">
<h2>Optimization functional<a class="headerlink" href="#optimization-functional" title="Permalink to this headline">¶</a></h2>
<p>Mathematically, Krotov’s method, when applied to quantum
systems <a class="bibtex reference internal" href="99_bibliography.html#tannor92" id="id15">[5]</a><a class="bibtex reference internal" href="99_bibliography.html#reichjcp12" id="id16">[22]</a>, minimizes a functional
of the most general form</p>
<div class="math notranslate nohighlight" id="equation-functional">
<span class="eqno">(1)<a class="headerlink" href="#equation-functional" title="Permalink to this equation">¶</a></span>\[J[\{\ket{\phi_k^{(i)}(t)}\}, \{\epsilon_l^{(i)}(t)\}]
    = J_T(\{\ket{\phi_k^{(i)}(T)}\})
        + \sum_l \int_0^T g_a(\epsilon_l^{(i)}(t)) \dd t
        + \int_0^T g_b(\{\phi^{(i)}_k(t)\}) \dd t\,,\]</div>
<p>where the <span class="math notranslate nohighlight">\(\{\ket{\phi_k^{(i)}(T)}\}\)</span> are the time-evolved
initial states <span class="math notranslate nohighlight">\(\{\ket{\phi_k}\}\)</span> under the controls
<span class="math notranslate nohighlight">\(\{\epsilon^{(i)}_l(t)\}\)</span> of the <span class="math notranslate nohighlight">\(i\)</span>’th iteration. In the
simplest case of a single state-to-state transition, the index <span class="math notranslate nohighlight">\(k\)</span>
vanishes. For the example of a two-qubit quantum gate,
<span class="math notranslate nohighlight">\(\{\ket{\phi_k}\}\)</span> would be the logical basis states
<span class="math notranslate nohighlight">\(\ket{00}\)</span>, <span class="math notranslate nohighlight">\(\ket{01}\)</span>, <span class="math notranslate nohighlight">\(\ket{10}\)</span>, and
<span class="math notranslate nohighlight">\(\ket{11}\)</span>, all evolving under the same Hamiltonian
<span class="math notranslate nohighlight">\(\Op{H}_k \equiv \Op{H}\)</span>. The sum over <span class="math notranslate nohighlight">\(l\)</span> vanishes if there
is only a single control. For open system dynamics, the states
<span class="math notranslate nohighlight">\(\{\ket{\phi_k}\}\)</span> may be density matrices.</p>
<p>The functional consists of three parts:</p>
<ul>
<li><p>A final time functional <span class="math notranslate nohighlight">\(J_T\)</span>. This is the “main” part of the
functional, and we can usually think of <span class="math notranslate nohighlight">\(J\)</span> as being an
auxiliary functional in the optimization of <span class="math notranslate nohighlight">\(J_T\)</span>.</p></li>
<li><p>A running cost on the control fields, <span class="math notranslate nohighlight">\(g_a\)</span>. The most commonly
used expression (and the only one currently supported by the
<a class="reference internal" href="API/krotov.html#module-krotov" title="krotov"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov</span></code></a> package) is <a class="bibtex reference internal" href="99_bibliography.html#palaopra2003" id="id17">[47]</a></p>
<div class="math notranslate nohighlight" id="equation-g-a">
<span class="eqno">(2)<a class="headerlink" href="#equation-g-a" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{split}
    g_a(\epsilon_l^{(i)}(t))
    &amp;= \frac{\lambda_{a,l}}{S_l(t)} \left(
        \epsilon_l^{(i)}(t) - \epsilon_{l, \text{ref}}^{(i)}(t)
      \right)^2\,;
      \quad
    \epsilon^{(i)}_{l, \text{ref}}(t) = \epsilon_l^{(i-1)}(t)\\
   &amp;= \frac{\lambda_{a,l}}{S_l(t)} \left( \Delta\epsilon_l^{(i)}(t) \right)^2
   \,,
  \end{split}\end{split}\]</div>
<p>with the inverse “step width” <span class="math notranslate nohighlight">\(\lambda_{a,l} &gt; 0\)</span>, the “update
shape” function <span class="math notranslate nohighlight">\(S_{l}(t) \in [0, 1]\)</span>, and the <a class="reference internal" href="#iterativecontrolupdate"><span class="std std-ref">Iterative control update</span></a></p>
<div class="math notranslate nohighlight" id="equation-update">
<span class="eqno">(3)<a class="headerlink" href="#equation-update" title="Permalink to this equation">¶</a></span>\[\Delta\epsilon_l^{(i)}(t)
\equiv \epsilon_l^{(i)}(t) - \epsilon_l^{(i-1)}(t)\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(\epsilon_l^{(i-1)}(t)\)</span> is the optimized control of the
previous iteration – that is, the guess control of the current
iteration <span class="math notranslate nohighlight">\((i)\)</span>.</p>
</li>
<li><p>An optional state-dependent running cost, <span class="math notranslate nohighlight">\(g_b\)</span>. This may be
used to encode time-dependent control
targets <a class="bibtex reference internal" href="99_bibliography.html#kaiserjcp2004" id="id18">[48]</a><a class="bibtex reference internal" href="99_bibliography.html#serbanpra2005" id="id19">[49]</a>, or to penalize population in a
subspace <a class="bibtex reference internal" href="99_bibliography.html#palaopra2008" id="id20">[50]</a>. The presence of a
state-dependent constraint in the functional entails an inhomogeneous
term in the backward propagation in the calculation of the control
updates in each iteration of Krotov’s method, see Eq. <a class="reference internal" href="#equation-bw-eqm">(14)</a>, and is
currently not supported by the <a class="reference internal" href="API/krotov.html#module-krotov" title="krotov"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov</span></code></a> package. Penalizing
population in a subspace can also be achieved through simpler methods
that do not require a <span class="math notranslate nohighlight">\(g_b\)</span>, e.g., by using a non-Hermitian
Hamiltonian to remove population from the forbidden subspace during
the time evolution.</p></li>
</ul>
<p>The most commonly used final-time functionals (cf. <a class="reference internal" href="API/krotov.functionals.html#module-krotov.functionals" title="krotov.functionals"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.functionals</span></code></a>)
optimize for a set of initial states <span class="math notranslate nohighlight">\(\{\ket{\phi_k}\}\)</span> to evolve to a
set of target states <span class="math notranslate nohighlight">\(\{\ket{\phi_k^\tgt}\}\)</span>.  The functionals can then
be expressed in terms of the complex overlaps of the target states with the
final-time states under the given control. Thus,</p>
<div class="math notranslate nohighlight" id="equation-tauk">
<span class="eqno">(4)<a class="headerlink" href="#equation-tauk" title="Permalink to this equation">¶</a></span>\[  \tau_k = \Braket{\phi_k^\tgt}{\phi_k(T)}\]</div>
<p>in Hilbert space, or</p>
<div class="math notranslate nohighlight">
\[\tau_k
= \langle\!\langle \Op{\rho}^{\tgt} \vert \Op{\rho}_k(T) \rangle\!\rangle
\equiv \tr\left[\Op{\rho}_k^{\tgt\,\dagger} \Op{\rho}_k(T) \right]\]</div>
<p>in Liouville space.</p>
<p>The following functionals <span class="math notranslate nohighlight">\(J_T\)</span> can be formed from these complex
overlaps, taking into account that any optimization functional <span class="math notranslate nohighlight">\(J_T\)</span> must
be real. They differ by the way they treat the phases <span class="math notranslate nohighlight">\(\varphi_k\)</span> in the
physical optimization goal <span class="math notranslate nohighlight">\(\ket{\phi_k(T)} \overset{!}{=}
e^{i\varphi_k}\ket{\phi_k^{\tgt}}\)</span> <a class="bibtex reference internal" href="99_bibliography.html#palaopra2003" id="id21">[47]</a>:</p>
<ul>
<li><p>Optimize for simultaneous state-to-state transitions, with completely
arbitrary phases <span class="math notranslate nohighlight">\(\varphi_k\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-jtss">
<span class="eqno">(5)<a class="headerlink" href="#equation-jtss" title="Permalink to this equation">¶</a></span>\[J_{T,\text{ss}} = 1- \frac{1}{N} \sum_{k=1}^{N} \Abs{\tau_k}^2\,,\]</div>
<p>cf. <a class="reference internal" href="API/krotov.functionals.html#krotov.functionals.J_T_ss" title="krotov.functionals.J_T_ss"><code class="xref py py-func docutils literal notranslate"><span class="pre">J_T_ss()</span></code></a>.</p>
</li>
<li><p>Optimize for simultaneous state-to-state transitions, with an arbitrary
<em>global</em> phase, i.e., <span class="math notranslate nohighlight">\(\varphi_k = \varphi_{\text{global}}\)</span> for all
<span class="math notranslate nohighlight">\(k\)</span> with arbitrary <span class="math notranslate nohighlight">\(\varphi_{\text{global}}\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-jtsm">
<span class="eqno">(6)<a class="headerlink" href="#equation-jtsm" title="Permalink to this equation">¶</a></span>\[J_{T,\text{sm}} = 1- \frac{1}{N^2} \Abs{\sum_{k=1}^{N} \tau_k}^2
        = 1- \frac{1}{N^2} \sum_{k=1}^{N} \sum_{k'=1}^{N} \tau_{k'}^* \tau_{k}\,,\]</div>
<p>cf. <a class="reference internal" href="API/krotov.functionals.html#krotov.functionals.J_T_sm" title="krotov.functionals.J_T_sm"><code class="xref py py-func docutils literal notranslate"><span class="pre">J_T_sm()</span></code></a>.</p>
</li>
<li><p>Optimize for simultaneous state-to-state transitions, with a global phase of zero, i.e.,
<span class="math notranslate nohighlight">\(\varphi_k = 0\)</span> for all <span class="math notranslate nohighlight">\(k\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-jtre">
<span class="eqno">(7)<a class="headerlink" href="#equation-jtre" title="Permalink to this equation">¶</a></span>\[J_{T,\text{re}} = 1-\frac{1}{N} \Re \left[\, \sum_{k=1}^{N} \tau_k \,\right]\,,\]</div>
<p>cf. <a class="reference internal" href="API/krotov.functionals.html#krotov.functionals.J_T_re" title="krotov.functionals.J_T_re"><code class="xref py py-func docutils literal notranslate"><span class="pre">J_T_re()</span></code></a>.</p>
</li>
</ul>
</div>
<div class="section" id="iterative-control-update">
<span id="iterativecontrolupdate"></span><h2>Iterative control update<a class="headerlink" href="#iterative-control-update" title="Permalink to this headline">¶</a></h2>
<p>Starting from the initial guess control <span class="math notranslate nohighlight">\(\epsilon_l^{(0)}(t)\)</span>, the
optimized field <span class="math notranslate nohighlight">\(\epsilon_l^{(i)}(t)\)</span> in iteration <span class="math notranslate nohighlight">\(i &gt; 0\)</span>
is the result of applying a control update,</p>
<div class="math notranslate nohighlight" id="equation-eps-update">
<span class="eqno">(8)<a class="headerlink" href="#equation-eps-update" title="Permalink to this equation">¶</a></span>\[\epsilon_l^{(i)}(t)
= \epsilon_l^{(i-1)}(t) + \Delta\epsilon_l^{(i)}(t)\,.\]</div>
<p>Krotov’s method is a clever construction of a particular
<span class="math notranslate nohighlight">\(\Delta\epsilon_l^{(i)}(t)\)</span> that ensures</p>
<div class="math notranslate nohighlight">
\[J[\{\ket{\phi_k^{(i)}(t)}\}, \{\epsilon_l^{(i)}(t)\}] \leq
  J[\{\ket{\phi_k^{(i-1)}(t)}\}, \{\epsilon_l^{(i-1)}(t)\}]\,.\]</div>
<p>Krotov’s solution for <span class="math notranslate nohighlight">\(\Delta\epsilon_l^{(i)}(t)\)</span> is given in
below (<a class="reference internal" href="#firstorderupdate"><span class="std std-ref">First order update</span></a> and <a class="reference internal" href="#secondorderupdate"><span class="std std-ref">Second order update</span></a>).
As shown there,
for the specific running cost of Eq. <a class="reference internal" href="#equation-g-a">(2)</a>, using the
guess control field <span class="math notranslate nohighlight">\(\epsilon_l^{(i-1)}(t)\)</span> as the “reference”
field, the update <span class="math notranslate nohighlight">\(\Delta\epsilon^{(i)}_l(t)\)</span> is proportional to
<span class="math notranslate nohighlight">\(\frac{S_l(t)}{\lambda_{a,l}}\)</span>. Note that this also makes
<span class="math notranslate nohighlight">\(g_a\)</span> proportional to <span class="math notranslate nohighlight">\(\frac{S_l(t)}{\lambda_{a,l}}\)</span>, so
that Eq. <a class="reference internal" href="#equation-g-a">(2)</a> is still well-defined for
<span class="math notranslate nohighlight">\(S_l(t) = 0\)</span>. The (inverse) Krotov step width
<span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span> can be used to determine the overall magnitude of
<span class="math notranslate nohighlight">\(\Delta\epsilon^{(i)}_l(t)\)</span>. Values that are too large will change
<span class="math notranslate nohighlight">\(\epsilon_l^{(i)}(t)\)</span> by only a small amount in every iteration,
causing slow convergence. Values that are too small will result in numerical
instability, see <a class="reference internal" href="#timediscretization"><span class="std std-ref">Time discretization</span></a> and <a class="reference internal" href="#choiceoflambdaa"><span class="std std-ref">Choice of λₐ</span></a>.  The
“update shape” function <span class="math notranslate nohighlight">\(S_l(t)\)</span> allows to ensure boundary conditions on
<span class="math notranslate nohighlight">\(\epsilon^{(i)}_l(t)\)</span>: If both the guess field
<span class="math notranslate nohighlight">\(\epsilon^{(i-1)}_l(t)\)</span> and <span class="math notranslate nohighlight">\(S_l(t)\)</span> switch on and off smoothly
around <span class="math notranslate nohighlight">\(t=0\)</span> and <span class="math notranslate nohighlight">\(t=T\)</span>, then this feature will be preserved by the
optimization. A typical example for an update shape is</p>
<blockquote>
<div><div class="math notranslate nohighlight" id="equation-flattop">
<span class="eqno">(9)<a class="headerlink" href="#equation-flattop" title="Permalink to this equation">¶</a></span>\[\begin{split}S_l(t) = \begin{cases}
      B(t; t_0=0, t_1=2 t_{\text{on}})
        &amp; \text{for} \quad 0 &lt; t &lt; t_{\text{on}} \\
      1 &amp; \text{for} \quad t_{\text{on}} \le t \le T - t_{\text{off}} \\
      B(t; t_0=T-2 t_{\text{off}}, t_1=T)
        &amp; \text{for} \quad T - t_{\text{off}} &lt; t &lt; T\,,
    \end{cases}\end{split}\]</div>
<p>cf. <a class="reference internal" href="API/krotov.shapes.html#krotov.shapes.flattop" title="krotov.shapes.flattop"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.shapes.flattop()</span></code></a>, with the <a class="reference external" href="https://en.wikipedia.org/wiki/Window_function#Blackman_window">Blackman shape</a></p>
<div class="math notranslate nohighlight" id="equation-blackman">
<span class="eqno">(10)<a class="headerlink" href="#equation-blackman" title="Permalink to this equation">¶</a></span>\[B(t; t_0, t_1) =
      \frac{1}{2}\left(
        1 - a - \cos\left(2\pi \frac{t - t_0}{t_1 - t_0}\right)
        + a \cos\left(4\pi \frac{t - t_0}{t_1 - t_0}\right)
      \right)\,,\quad a = 0.16\,,\]</div>
</div></blockquote>
<p>which is similar to a Gaussian, but exactly zero at
<span class="math notranslate nohighlight">\(t = t_0, t_1\)</span>. This is essential to maintain the typical boundary
condition of zero amplitude at the beginning and end of the optimized
control field. Generally, <em>any</em> part of the control field can be kept
unchanged in the optimization by choosing <span class="math notranslate nohighlight">\(S_l(t) = 0\)</span> for the
corresponding intervals of the time grid.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the remainder of this chapter, we review some of the mathematical details
of how Krotov’s method calculates the update in Eqs. <a class="reference internal" href="#equation-update">(3)</a>, <a class="reference internal" href="#equation-eps-update">(8)</a>.
These details are not necessary to <em>use</em> the <a class="reference internal" href="API/krotov.html#module-krotov" title="krotov"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov</span></code></a> package as a
“black box” optimization tool, so you may skip ahead to
<a class="reference internal" href="08_qutip_usage.html#using-krotov-with-qutip"><span class="std std-ref">Using Krotov with QuTiP</span></a> and come back at a later time.</p>
</div>
</div>
<div class="section" id="first-order-update">
<span id="firstorderupdate"></span><h2>First order update<a class="headerlink" href="#first-order-update" title="Permalink to this headline">¶</a></h2>
<p>Krotov’s method is based on a rigorous examination of the conditions for
calculating the updated fields <span class="math notranslate nohighlight">\(\{\epsilon_l^{(i)}(t)\}\)</span> such that
<span class="math notranslate nohighlight">\(J(\{\ket{\phi_k^{(i)}(t)}\}, \{\epsilon_l^{(i)}(t)\}) \leq
J(\{\ket{\phi_k^{(i-1)}(t)}\}, \{\epsilon_l^{(i-1)}(t)\})\)</span> is true <em>by
construction</em> <a class="bibtex reference internal" href="99_bibliography.html#krotov-book" id="id22">[42]</a><a class="bibtex reference internal" href="99_bibliography.html#konnovarc99" id="id23">[43]</a><a class="bibtex reference internal" href="99_bibliography.html#palaopra2003" id="id24">[47]</a><a class="bibtex reference internal" href="99_bibliography.html#sklarzpra2002" id="id25">[46]</a><a class="bibtex reference internal" href="99_bibliography.html#reichjcp12" id="id26">[22]</a>.
For a general functional of the form in
Eq. <a class="reference internal" href="#equation-functional">(1)</a>, with a convex final-time
functional <span class="math notranslate nohighlight">\(J_T\)</span>, the condition for monotonic convergence is</p>
<div class="math notranslate nohighlight" id="equation-krotov-first-order-proto-update">
<span class="eqno">(11)<a class="headerlink" href="#equation-krotov-first-order-proto-update" title="Permalink to this equation">¶</a></span>\[\frac{\partial g_a}{\partial \epsilon_l(t)}\bigg\vert_{(i)}
  =  2 \Im \left[\,
      \sum_{k=1}^{N} \Bigg\langle \chi_k^{(i-1)}(t) \Bigg\vert \Bigg(
      \frac{\partial \Op{H}}{\partial \epsilon_l(t)}\bigg\vert_{
      (i)} \Bigg)
      \Bigg\vert \phi_k^{(i)}(t) \Bigg\rangle
    \right]\,,\]</div>
<p>see Ref. <a class="bibtex reference internal" href="99_bibliography.html#palaopra2003" id="id27">[47]</a>.
The notation for the derivative on the right hand side being evaluated
at <span class="math notranslate nohighlight">\({(i)}\)</span> should be understood to apply when the control
Hamiltonian is not linear so that
<span class="math notranslate nohighlight">\(\frac{\partial \Op{H}}{\partial \epsilon_l(t)}\)</span> is still
time-dependent; the derivative must then be evaluated for
<span class="math notranslate nohighlight">\(\epsilon^{(i)}_l(t)\)</span> – or, numerically, for
<span class="math notranslate nohighlight">\(\epsilon^{(i-1)}_l(t) \approx \epsilon^{(i)}_l(t)\)</span>. If there are
multiple controls, Eq. <a class="reference internal" href="#equation-krotov-first-order-proto-update">(11)</a>
holds for every control field <span class="math notranslate nohighlight">\(\epsilon_l(t)\)</span> independently.</p>
<p>For <span class="math notranslate nohighlight">\(g_a\)</span> as in Eq. <a class="reference internal" href="#equation-g-a">(2)</a>, this results in an
<em>update</em>
equation <a class="bibtex reference internal" href="99_bibliography.html#tannor92" id="id28">[5]</a><a class="bibtex reference internal" href="99_bibliography.html#palaopra2003" id="id29">[47]</a><a class="bibtex reference internal" href="99_bibliography.html#sklarzpra2002" id="id30">[46]</a>,</p>
<div class="math notranslate nohighlight" id="equation-krotov-first-order-update">
<span class="eqno">(12)<a class="headerlink" href="#equation-krotov-first-order-update" title="Permalink to this equation">¶</a></span>\[\Delta\epsilon^{(i)}_l(t)
  = \frac{S_l(t)}{\lambda_{a,l}} \Im \left[\,
      \sum_{k=1}^{N} \Bigg\langle \chi_k^{(i-1)}(t) \Bigg\vert \Bigg(
      \frac{\partial \Op{H}}{\partial \epsilon_l(t)}
      \bigg\vert_{(i)} \Bigg)
      \Bigg\vert \phi_k^{(i)}(t) \Bigg\rangle
    \right]\,,\]</div>
<p>with the equation of motion for the forward propagation of
<span class="math notranslate nohighlight">\(\ket{\phi_k^{(i)}}\)</span> under the optimized controls
<span class="math notranslate nohighlight">\(\{\epsilon_l^{(i)}(t)\}\)</span> of the iteration <span class="math notranslate nohighlight">\((i)\)</span>,</p>
<div class="math notranslate nohighlight" id="equation-fw-eqm">
<span class="eqno">(13)<a class="headerlink" href="#equation-fw-eqm" title="Permalink to this equation">¶</a></span>\[\frac{\partial}{\partial t} \Ket{\phi_k^{(i)}(t)}
   = -\frac{\mathrm{i}}{\hbar} \Op{H}^{(i)} \Ket{\phi_k^{(i)}(t)}\,.\]</div>
<p>The co-states <span class="math notranslate nohighlight">\(\ket{\chi_k^{(i-1)}(t)}\)</span> are propagated backwards
in time under the guess controls of iteration <span class="math notranslate nohighlight">\((i)\)</span>, i.e., the
optimized controls from the previous iteration <span class="math notranslate nohighlight">\((i-1)\)</span>, as</p>
<div class="math notranslate nohighlight" id="equation-bw-eqm">
<span class="eqno">(14)<a class="headerlink" href="#equation-bw-eqm" title="Permalink to this equation">¶</a></span>\[\frac{\partial}{\partial t} \Ket{\chi_k^{(i-1)}(t)}
  = -\frac{\mathrm{i}}{\hbar} \Op{H}^{\dagger\,(i-1)} \Ket{\chi_k^{(i-1)}(t)}
    + \left.\frac{\partial g_b}{\partial \Bra{\phi_k}}\right\vert_{(i-1)}\,,\]</div>
<p>with the boundary condition</p>
<div class="math notranslate nohighlight" id="equation-chi-boundary">
<span class="eqno">(15)<a class="headerlink" href="#equation-chi-boundary" title="Permalink to this equation">¶</a></span>\[\Ket{\chi_k^{(i-1)}(T)}
  = - \left.\frac{\partial J_T}{\partial \Bra{\phi_k(T)}}
    \right\vert_{(i-1)}\,,\]</div>
<p>where the right-hand-side is evaluated for the set of states
<span class="math notranslate nohighlight">\(\{\ket{\phi_k^{(i-1)}(T)}\}\)</span> resulting from the forward-propagation of
the initial states under the guess controls of iteration <span class="math notranslate nohighlight">\((i)\)</span> – that is,
the optimized controls of the previous iteration <span class="math notranslate nohighlight">\((i-1)\)</span>.</p>
<p>For example, for the functional <span class="math notranslate nohighlight">\(J_{T,\text{ss}}\)</span> in Eq. <a class="reference internal" href="#equation-jtss">(5)</a> for
a single state-to-state transition (<span class="math notranslate nohighlight">\(N=1\)</span>),</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  \ket{\chi^{(i-1)}(T)}
   &amp;= \frac{\partial}{\partial \Bra{\phi(T)}}
       \underbrace{%
         \Braket{\phi(T)}{\phi^\tgt}
         \Braket{\phi^\tgt}{\phi(T)}
       }_{\Abs{\Braket{\phi^\tgt}{\phi(T)}}^2}
       \Bigg\vert_{(i-1)} \\
   &amp;= \left(\Braket{\phi^\tgt}{\phi^{(i-1)}(T)}\right) \Ket{\phi^\tgt}\,,
\end{split}\end{split}\]</div>
<p>cf. <a class="reference internal" href="API/krotov.functionals.html#krotov.functionals.chis_ss" title="krotov.functionals.chis_ss"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.functionals.chis_ss()</span></code></a> and the <a class="reference internal" href="API/krotov.functionals.html#module-krotov.functionals" title="krotov.functionals"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.functionals</span></code></a> module
in general.</p>
</div>
<div class="section" id="second-order-update">
<span id="secondorderupdate"></span><h2>Second order update<a class="headerlink" href="#second-order-update" title="Permalink to this headline">¶</a></h2>
<p>The update
Eq. <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a>
assumes that the equation of motion is linear (<span class="math notranslate nohighlight">\(\Op{H}\)</span> does not
depend on the states <span class="math notranslate nohighlight">\(\ket{\phi_k(t)}\)</span>), the functional
<span class="math notranslate nohighlight">\(J_T\)</span> is convex, and no state-dependent constraints are used
(<span class="math notranslate nohighlight">\(g_b\equiv 0\)</span>). When any of these conditions are not fulfilled,
it is still possible to derive an optimization algorithm with monotonic
convergence via a “second order” term in
Eqs. <a class="reference internal" href="#equation-krotov-first-order-proto-update">(11)</a>, <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a> <a class="bibtex reference internal" href="99_bibliography.html#konnovarc99" id="id31">[43]</a><a class="bibtex reference internal" href="99_bibliography.html#reichjcp12" id="id32">[22]</a>,</p>
<p>The full update equation then reads</p>
<div class="math notranslate nohighlight" id="equation-krotov-second-order-update">
<span class="eqno">(16)<a class="headerlink" href="#equation-krotov-second-order-update" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{split}
  \Delta\epsilon^{(i)}_l(t)
    &amp;= \frac{S_l(t)}{\lambda_{a,l}} \Im \left[\,
        \sum_{k=1}^{N} \Bigg\langle \chi_k^{(i-1)}(t) \Bigg\vert \Bigg(
        \frac{\partial \Op{H}}{\partial \epsilon_l(t)}
        \bigg\vert_{(i)} \Bigg)
        \Bigg\vert \phi_k^{(i)}(t) \Bigg\rangle
      \right. \\ &amp; \qquad \qquad \quad \left.
        + \frac{1}{2} \sigma(t)
        \Bigg\langle \Delta\phi_k^{(i)}(t) \Bigg\vert \Bigg(
        \frac{\partial \Op{H}}{\partial \epsilon_l(t)}
        \bigg\vert_{(i)} \Bigg)
        \Bigg\vert \phi_k^{(i)}(t) \Bigg\rangle
      \right]\,,
\end{split}\end{split}\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[\ket{\Delta \phi_k^{(i)}(t)}
  \equiv \ket{\phi_k^{(i)}(t)} - \ket{\phi_k^{(i-1)}(t)}\,,\]</div>
<p>see Ref. <a class="bibtex reference internal" href="99_bibliography.html#reichjcp12" id="id33">[22]</a> for the full construction of
the second-order condition.
In Eq. <a class="reference internal" href="#equation-krotov-second-order-update">(16)</a>,
<span class="math notranslate nohighlight">\(\sigma(t)\)</span> is a scalar function that must be properly chosen to
ensure monotonic convergence.</p>
<p>In Refs. <a class="bibtex reference internal" href="99_bibliography.html#wattspra2015" id="id34">[28]</a><a class="bibtex reference internal" href="99_bibliography.html#goerzpra2015" id="id35">[29]</a>, a non-convex
final-time functional for the optimization towards an arbitrary perfect
entangler is considered. For this specific example, a suitable choice is</p>
<div class="math notranslate nohighlight">
\[\sigma(t) \equiv -\max\left(\varepsilon_A,2A+\varepsilon_A\right)\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(\varepsilon_A\)</span> is a small non-negative number. The optimal
value for <span class="math notranslate nohighlight">\(A\)</span> in each iteration can be approximated numerically
as <a class="bibtex reference internal" href="99_bibliography.html#reichjcp12" id="id36">[22]</a></p>
<div class="math notranslate nohighlight">
\[\label{eq:numericalA}
  A = \frac{
    \sum_{k=1}^{N} 2 \Re\left[
      \langle \chi_k(T) \vert \Delta\phi_k(T) \rangle \right] + \Delta J_T}{
    \sum_{k=1}^{N} \Abs{\Delta\phi_k(T)}^2} \,,\]</div>
<p>cf. <a class="reference internal" href="API/krotov.second_order.html#krotov.second_order.numerical_estimate_A" title="krotov.second_order.numerical_estimate_A"><code class="xref py py-func docutils literal notranslate"><span class="pre">krotov.second_order.numerical_estimate_A()</span></code></a>, with</p>
<p>with</p>
<div class="math notranslate nohighlight">
\[\Delta J_T \equiv J_T(\{\phi_k^{(i)}(T)\}) -J_T(\{\phi_k^{(i-1)}(T)\})\,.\]</div>
<p>See the <a class="reference internal" href="notebooks/07_example_PE.html"><span class="std std-ref">Optimization towards a Perfect Entangler</span></a> for an example.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Even when the second order update equation is mathematically required to
guarantee monotonic convergence, very often an optimization with the
first-order update equation <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a> will give
converging results. Since the second order update requires
more numerical resources (calculation and storage of the states
<span class="math notranslate nohighlight">\(\ket{\Delta\phi_k(t)}\)</span>), you should always try the optimization with
the first-order update equation first.</p>
</div>
</div>
<div class="section" id="time-discretization">
<span id="timediscretization"></span><h2>Time discretization<a class="headerlink" href="#time-discretization" title="Permalink to this headline">¶</a></h2>
<div class="figure align-default" id="id42">
<span id="figkrotovscheme"></span><a class="reference internal image-reference" href="_images/krotovscheme.svg"><img alt="Sequential update scheme in Krotov’s method on a time grid." src="_images/krotovscheme.svg" width="100%" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Sequential update scheme in Krotov’s method on a time grid.</span><a class="headerlink" href="#id42" title="Permalink to this image">¶</a></p>
</div>
<p>The derivation of Krotov’s method assumes time-continuous control
fields. Only in this case, monotonic convergence is mathematically
guaranteed. However, for practical numerical applications, we have to
consider controls on a discrete time grid with <span class="math notranslate nohighlight">\(N_T+1\)</span> points running
from <span class="math notranslate nohighlight">\(t=t_0=0\)</span> to <span class="math notranslate nohighlight">\(t=t_{N_T}=T\)</span>, with a time step <span class="math notranslate nohighlight">\(\dd t\)</span>. The
states are defined on the points of the time grid, while the controls
are assumed to be constant on the intervals of the time grid.
See the notebook <a class="reference external" href="https://nbviewer.jupyter.org/gist/goerz/21e46ea7b45c9514e460007de14419bd/Krotov_time_discretization.ipynb#">Time Discretization in Quantum Optimal Control</a>
for details.</p>
<p>The discretization yields the numerical scheme shown in
<a class="reference internal" href="#figkrotovscheme"><span class="std std-numref">Fig. 1</span></a> for a single control
field (no index <span class="math notranslate nohighlight">\(l\)</span>), and assuming the first-order update is
sufficient to guarantee monotonic convergence for the chosen functional.
For simplicity, we also assume that the Hamiltonian is linear in the
control, so that <span class="math notranslate nohighlight">\(\partial \Op{H} / \partial \epsilon(t)\)</span> is not
time-dependent. The scheme proceeds as follows:</p>
<ol class="arabic">
<li><p>Construct the states <span class="math notranslate nohighlight">\(\{\ket{\chi^{(i-1)}_k(T)}\}\)</span> according to
Eq. <a class="reference internal" href="#equation-chi-boundary">(15)</a>. For most functionals,
specifically any that are more than linear in the overlaps
<span class="math notranslate nohighlight">\(\tau_k\)</span> defined in Eq. <a class="reference internal" href="#equation-tauk">(4)</a>, the states
<span class="math notranslate nohighlight">\(\{\ket{\chi^{(i-1)}_k(T)}\}\)</span> depend on the states
<span class="math notranslate nohighlight">\(\{\ket{\phi^{(i-1)}_k(T)}\}\)</span> forward-propagated under the
optimized pulse from the previous iteration, that is, the guess pulse
in the current iteration.</p></li>
<li><p>Perform a backward propagation using
Eq. <a class="reference internal" href="#equation-bw-eqm">(14)</a> as the equation of motion over the
entire time grid. The resulting state at each point in the time grid
must be stored in memory.</p></li>
<li><p>Starting from the known initial states
<span class="math notranslate nohighlight">\(\{\ket{\phi_k}\} = \{\ket{\phi_k(t=t_0=0)}\}\)</span>, calculate the pulse
update for the first time step according to</p>
<div class="math notranslate nohighlight" id="equation-update-discretized0">
<span class="eqno">(17)<a class="headerlink" href="#equation-update-discretized0" title="Permalink to this equation">¶</a></span>\[\Delta\epsilon^{(i)}_1
      \equiv \Delta\epsilon^{(i)}(\tilde{t}_0)
      = \frac{S(\tilde{t}_0)}{\lambda_{a}} \Im \left[\,
          \sum_{k=1}^{N} \bigg\langle \chi_k^{(i-1)}(t_0) \bigg\vert
          \frac{\partial \Op{H}}{\partial \epsilon}
          \bigg\vert \phi_k(t_0) \bigg\rangle
        \right]\,.\]</div>
<p>The value <span class="math notranslate nohighlight">\(\Delta\epsilon^{(i)}_1\)</span> is taken on the midpoint of
the first time interval, <span class="math notranslate nohighlight">\(\tilde{t}_0 \equiv t_0 + \dd t/2\)</span>,
based on the assumption of a piecewise-constant control field and an
equidistant time grid with spacing <span class="math notranslate nohighlight">\(\dd t\)</span>.</p>
</li>
<li><p>Use the updated field <span class="math notranslate nohighlight">\(\epsilon^{(i)}_1\)</span> for the first interval
to propagate <span class="math notranslate nohighlight">\(\ket{\phi_k(t=t_0)}\)</span> for a single time step to
<span class="math notranslate nohighlight">\(\ket{\phi_k^{(i)}(t=t_0 + \dd t)}\)</span>, with
Eq. <a class="reference internal" href="#equation-fw-eqm">(13)</a> as the equation of motion. The
updates then proceed sequentially, using the discretized update
equation</p>
<div class="math notranslate nohighlight" id="equation-update-discretized">
<span class="eqno">(18)<a class="headerlink" href="#equation-update-discretized" title="Permalink to this equation">¶</a></span>\[\Delta\epsilon^{(i)}_{n+1}
      \equiv \Delta\epsilon^{(i)}(\tilde{t}_n)
      = \frac{S(\tilde{t}_n)}{\lambda_{a}} \Im \left[\,
          \sum_{k=1}^{N} \bigg\langle \chi_k^{(i-1)}(t_n) \bigg\vert
          \frac{\partial \Op{H}}{\partial \epsilon}
          \bigg\vert \phi_k^{(i)}(t_n) \bigg\rangle
        \right]\]</div>
<p>with <span class="math notranslate nohighlight">\(\tilde{t}_n \equiv t_n + \dd t / 2\)</span> for each time
interval <span class="math notranslate nohighlight">\(n\)</span>, until the final forward-propagated state
<span class="math notranslate nohighlight">\(\ket{\phi^{(i)}_k(T)}\)</span> is reached.</p>
</li>
<li><p>The updated control field becomes the guess control for the next
iteration of the algorithm, starting again at step 1. The
optimization continues until the value of the functional <span class="math notranslate nohighlight">\(J_T\)</span>
falls below some predefined threshold, or convergence is reached,
i.e., <span class="math notranslate nohighlight">\(\Delta J_T\)</span> approaches zero so that no further significant
improvement of <span class="math notranslate nohighlight">\(J_T\)</span> is to be expected.</p></li>
</ol>
<p>Eq. <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a>
re-emerges as the continuous limit of the time-discretized update
equation <a class="reference internal" href="#equation-update-discretized">(18)</a>, i.e.,
<span class="math notranslate nohighlight">\(\dd t \rightarrow 0\)</span> so that <span class="math notranslate nohighlight">\(\tilde{t}_n \rightarrow t_n\)</span>.
Note that Eq. <a class="reference internal" href="#equation-update-discretized">(18)</a>
resolves the seeming contradiction in the time-continuous
Eq. <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a>
that the calculation of <span class="math notranslate nohighlight">\(\epsilon^{(i)}(t)\)</span> requires knowledge of
the states <span class="math notranslate nohighlight">\(\ket{\phi_k^{(i)}(t)}\)</span> which would have to be obtained
from a propagation under <span class="math notranslate nohighlight">\(\epsilon^{(i)}(t)\)</span>. By having the time
argument <span class="math notranslate nohighlight">\(\tilde{t}_n\)</span> on the left-hand-side of
Eq. <a class="reference internal" href="#equation-update-discretized">(18)</a>, and
<span class="math notranslate nohighlight">\(t_n &lt; \tilde{t}_n\)</span> on the right-hand-side (with
<span class="math notranslate nohighlight">\(S(\tilde{t}_n)\)</span> known at all times), the update for each interval
only depends on “past” information.</p>
<p>For multiple objectives, the scheme can run in parallel, and each objective
contributes a term to the update. Summation of these terms yields the sum
in Eq. <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a>. See <a class="reference internal" href="API/krotov.parallelization.html#module-krotov.parallelization" title="krotov.parallelization"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.parallelization</span></code></a> for
details. For a second-order update, the forward propagated states from step 4,
both for the current iteration and the previous iteration, must be stored in
memory over the entire time grid.</p>
</div>
<div class="section" id="pseudocode">
<h2>Pseudocode<a class="headerlink" href="#pseudocode" title="Permalink to this headline">¶</a></h2>
<p>A complete pseudocode for Krotov’s method as described in the previous section
<a class="reference internal" href="#timediscretization"><span class="std std-ref">Time discretization</span></a> is available in PDF format: <a class="reference external" href="krotov_pseudocode.pdf">krotov_pseudocode.pdf</a>.</p>
</div>
<div class="section" id="choice-of-a">
<span id="choiceoflambdaa"></span><h2>Choice of λₐ<a class="headerlink" href="#choice-of-a" title="Permalink to this headline">¶</a></h2>
<p>The monotonic convergence of Krotov’s method is only guaranteed in the
continuous limit; a coarse
time step must be compensated by larger values of the inverse step size
<span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span>, slowing down convergence. Values that are too
small will cause sharp spikes in the optimized control and numerical
instabilities. A lower limit for <span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span> can be determined
from the requirement that the change <span class="math notranslate nohighlight">\(\Delta\epsilon_l^{(i)}(t)\)</span>
should be at most of the same order of magnitude as the guess pulse
<span class="math notranslate nohighlight">\(\epsilon_l^{(i-1)}(t)\)</span> for that iteration. The Cauchy-Schwarz
inequality applied to the update
equation <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a>
yields</p>
<div class="math notranslate nohighlight">
\[\Norm{\Delta \epsilon_l(t)}_{\infty}
  \le
  \frac{\Norm{S(t)}}{\lambda_{a,l}}
  \sum_{k} \Norm{\ket{\chi_k (t)}}_{\infty} \Norm{\ket{\phi_k (t)}}_{\infty}
  \Norm{\frac{\partial \Op{H}}{\partial \epsilon_l(t)}}_{\infty}
  \stackrel{!}{\le}
  \Norm{\epsilon_l^{(i)}(t)}_{\infty}\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(\norm{\partial \Op{H}/\partial \epsilon_l(t)}_{\infty}\)</span> denotes the
supremum norm of the operator <span class="math notranslate nohighlight">\(\partial \Op{H}/\partial \epsilon_l\)</span>
obtained at time <span class="math notranslate nohighlight">\(t\)</span>.  Since <span class="math notranslate nohighlight">\(S(t) \in [0,1]\)</span> and
<span class="math notranslate nohighlight">\(\ket{\phi_k}\)</span> are normalized, the condition for <span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[\lambda_{a,l} \ge
  \frac{1}{\Norm{\epsilon_l^{(i)}(t)}_{\infty}}
  \left[ \sum_{k} \Norm{\ket{\chi_k(t)}}_{\infty} \right]
  \Norm{\frac{\partial \Op{H}}{\partial \epsilon_l(t)}}_{\infty}\,.\]</div>
<p>From a practical point of view, the best strategy is to start the
optimization with a comparatively large value of <span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span>,
and after a few iterations lower <span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span> as far as
possible without introducing numerical instabilities. In principle, the value
of <span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span> may be adjusted dynamically with respect to the
rate of convergence, via the <cite>modify_params_after_iter</cite> argument to
<a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>. Generally, the ideal choice of
<span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span> requires some trial and error, but once a suitable value
has been found, it does not have to be adjusted further. In particular, it is
not necessary to perform a line search over <span class="math notranslate nohighlight">\(\lambda_{a,l}\)</span>.</p>
</div>
<div class="section" id="complex-controls-and-the-rwa">
<h2>Complex controls and the RWA<a class="headerlink" href="#complex-controls-and-the-rwa" title="Permalink to this headline">¶</a></h2>
<p>When using the rotating wave approximation (RWA), it is important to remember
that the target states are usually defined in the lab frame, not in the
rotating frame. This is relevant for the construction of
<span class="math notranslate nohighlight">\(\ket{\chi_k(T)}\)</span>. When doing a simple optimization, such as a
state-to-state or a gate optimization, the  easiest approach is to transform
the target states to the rotating frame before calculating
<span class="math notranslate nohighlight">\(\ket{\chi_k(T)}\)</span>. This is both straightforward and numerically
efficient.</p>
<p>Another solution would be to transform the result of the forward propagation
<span class="math notranslate nohighlight">\(\ket{\phi_k(T)}\)</span> from the rotating frame to the lab frame, then
constructing <span class="math notranslate nohighlight">\(\ket{\chi_k(T)}\)</span>, and finally to transform
<span class="math notranslate nohighlight">\(\ket{\chi_k(T)}\)</span> back to the rotating frame, before starting the
backward propagation.</p>
<p>When the RWA is used, the control fields are
complex-valued. In this case the Krotov update equation is valid for
both the real and the imaginary part independently. The most straightforward
implementation of the method is for real controls only, requiring that any
complex control Hamiltonian is rewritten as two independent control
Hamiltonians, one for the real part and one for the imaginary part of the
control field. For example,</p>
<div class="math notranslate nohighlight">
\[\epsilon^*(t) \Op{a} + \epsilon(t) \Op{a}^\dagger
=  \epsilon_{\text{re}}(t) (\Op{a} + \Op{a}^\dagger) + \epsilon_{\text{im}}(t) (i \Op{a}^\dagger - i \Op{a})\]</div>
<p>with two independent control fields <span class="math notranslate nohighlight">\(\epsilon_{\text{re}}(t)= \Re[\epsilon(t)]\)</span> and
<span class="math notranslate nohighlight">\(\epsilon_{\text{im}}(t) = \Im[\epsilon(t)]\)</span>.</p>
<p>See the <a class="reference internal" href="notebooks/02_example_lambda_system_rwa_complex_pulse.html"><span class="std std-ref">Optimization of a State-to-State Transfer in a Lambda System in the RWA</span></a> for an
example.</p>
</div>
<div class="section" id="optimization-in-liouville-space">
<h2>Optimization in Liouville space<a class="headerlink" href="#optimization-in-liouville-space" title="Permalink to this headline">¶</a></h2>
<p>The coupled equations <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a>–<a class="reference internal" href="#equation-bw-eqm">(14)</a> can be
generalized to open system dynamics by replacing Hilbert space states with
density matrices, <span class="math notranslate nohighlight">\(\Op{H}\)</span> with <span class="math notranslate nohighlight">\(\mathrm{i} \Liouville\)</span>, and brakets (inner products) with Hilbert-Schmidt products,
<span class="math notranslate nohighlight">\(\langle  \cdot \vert \cdot \rangle \rightarrow \langle\!\langle \cdot
\vert \cdot \rangle\!\rangle\)</span>. In full generality, <span class="math notranslate nohighlight">\(\Op{H}\)</span> in
Eq. <a class="reference internal" href="#equation-krotov-first-order-update">(12)</a> is the operator <span class="math notranslate nohighlight">\(H\)</span> on the right-hand
side of whatever the equation of motion for the forward propagation of the
states is, written in the form <span class="math notranslate nohighlight">\(\mathrm{i} \hbar \dot\phi = H \phi\)</span>,
cf. Eq. <a class="reference internal" href="#equation-fw-eqm">(13)</a>. See <a class="reference internal" href="API/krotov.mu.html#module-krotov.mu" title="krotov.mu"><code class="xref py py-mod docutils literal notranslate"><span class="pre">krotov.mu</span></code></a> for details.</p>
<p>Note also that the backward propagation Eq. <a class="reference internal" href="#equation-bw-eqm">(14)</a>
uses the adjoint <span class="math notranslate nohighlight">\(H\)</span>, which is relevant both for a dissipative
Liouvillian <a class="bibtex reference internal" href="99_bibliography.html#bartanajcp93" id="id37">[51]</a><a class="bibtex reference internal" href="99_bibliography.html#ohtsukijcp99" id="id38">[52]</a><a class="bibtex reference internal" href="99_bibliography.html#goerznjp2014" id="id39">[27]</a> and a non-Hermitian
Hamiltonian <a class="bibtex reference internal" href="99_bibliography.html#mullerqip11" id="id40">[25]</a><a class="bibtex reference internal" href="99_bibliography.html#goerzqst2018" id="id41">[53]</a>.</p>
<p>See the <a class="reference internal" href="notebooks/04_example_dissipative_qubit_reset.html"><span class="std std-ref">Optimization of Dissipative Qubit Reset</span></a> for an example.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="08_qutip_usage.html" class="btn btn-neutral float-right" title="Using Krotov with QuTiP" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="06_introduction.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Michael Goerz et al.
      <span class="lastupdated">
        Last updated on Dec 16, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>