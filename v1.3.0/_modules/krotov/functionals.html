<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>krotov.functionals &mdash; Krotov 1.3.0 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mycss.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="../../_static/docs-versions-menu.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Krotov
          </a>
              <div class="version">
                1.3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../01_overview.html">Krotov Python Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../02_contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../03_authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../04_features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../05_history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../06_introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../07_krotovs_method.html">Krotov’s Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../08_qutip_usage.html">Using Krotov with QuTiP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../09_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../10_howto.html">How-Tos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../11_other_methods.html">Other Optimization Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../12_related_software.html">Related Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../99_bibliography.html">References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../API/krotov.html">API of the Krotov package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Krotov</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          





















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>krotov.functionals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for krotov.functionals</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Functionals and `chi_constructor` routines.</span>

<span class="sd">Any `chi_constructor` routine passed to :func:`.optimize_pulses` must take the</span>
<span class="sd">following keyword-arguments:</span>

<span class="sd">    * `fw_states_T` (:class:`list` of :class:`~qutip.Qobj`): The list of</span>
<span class="sd">      states resulting from the forward-propagation of each</span>
<span class="sd">      :attr:`.Objective.initial_state` under the guess pulses of the current</span>
<span class="sd">      iteration (the optimized pulses of the previous iteration)</span>

<span class="sd">    * `objectives` (:class:`list` of :class:`.Objective`): A list of the</span>
<span class="sd">      optimization objectives.</span>

<span class="sd">    * `tau_vals` (:class:`list` of :class:`complex` or :obj:`None`): The</span>
<span class="sd">      overlaps of the :attr:`.Objective.target` and the corresponding</span>
<span class="sd">      `fw_states_T`, assuming :attr:`.Objective.target` contains a</span>
<span class="sd">      quantum state. If the objective defines no target state, a list of Nones</span>

<span class="sd">Krotov&#39;s method does not have an explicit dependence on the optimization</span>
<span class="sd">functional. It only enters through the `chi_constructor` which calculates the</span>
<span class="sd">boundary condition for the backward propagation, that is, the states</span>


<span class="sd">.. math::</span>

<span class="sd">   \Ket{\chi_k^{(i)}(T)}</span>
<span class="sd">      = - \left.\frac{\partial J_T}</span>
<span class="sd">        {\partial \Bra{\phi_k}}</span>
<span class="sd">        \right\vert_{\phi^{(i)}(T)}</span>

<span class="sd">for functionals defined in Hilbert space, or</span>

<span class="sd">.. math::</span>

<span class="sd">   \Op{\chi}_k^{(i)}(T)</span>
<span class="sd">      = - \left.\frac{\partial J_T}</span>
<span class="sd">        {\partial \langle\!\langle\Op{\rho}_k\vert}</span>
<span class="sd">        \right\vert_{\rho^{(i)}(T)}</span>

<span class="sd">in Liouville space, using the abstract</span>
<span class="sd">Hilbert-Schmidt notation :math:`\langle\!\langle a \vert b \rangle\!\rangle</span>
<span class="sd">\equiv \tr[a^\dagger b]`. The notation on the right hand side is a `Wirtinger</span>
<span class="sd">derivative`_, see Eq. :eq:`wirtinger_deriv`. Passing a specific</span>
<span class="sd">`chi_constructor` results in the minimization of the final time functional from</span>
<span class="sd">which that `chi_constructor` was derived.</span>

<span class="sd">The functions in this module that evaluate functionals are intended for use</span>
<span class="sd">inside a function that is passed as an `info_hook` to :func:`.optimize_pulses`.</span>
<span class="sd">Thus, they calculate $J_T$ from the same keyword arguments as the `info_hook`.</span>
<span class="sd">The values for $J_T$ may be used in a convergence analysis, see</span>
<span class="sd">:mod:`krotov.convergence`.</span>

<span class="sd">.. _Wirtinger derivative: https://en.wikipedia.org/wiki/Wirtinger_derivatives</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">qutip</span>

<span class="kn">from</span> <span class="nn">.second_order</span> <span class="kn">import</span> <span class="n">_overlap</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;f_tau&#39;</span><span class="p">,</span>
    <span class="s1">&#39;F_ss&#39;</span><span class="p">,</span>
    <span class="s1">&#39;J_T_ss&#39;</span><span class="p">,</span>
    <span class="s1">&#39;chis_ss&#39;</span><span class="p">,</span>
    <span class="s1">&#39;F_sm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;J_T_sm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;chis_sm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;F_re&#39;</span><span class="p">,</span>
    <span class="s1">&#39;J_T_re&#39;</span><span class="p">,</span>
    <span class="s1">&#39;chis_re&#39;</span><span class="p">,</span>
    <span class="s1">&#39;J_T_hs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;chis_hs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;F_avg&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gate&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mapped_basis&#39;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="f_tau"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.f_tau">[docs]</a><span class="k">def</span> <span class="nf">f_tau</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Average complex overlaps of the target states with the `fw_states_T`.</span>

<span class="sd">    That is,</span>

<span class="sd">    .. math::</span>

<span class="sd">        f_{\tau} = \frac{1}{N} \sum_{k=1}^{N} w_k \tau_k</span>

<span class="sd">    where $\tau_k$ are the elements of `tau_vals`, assumed to be</span>

<span class="sd">    .. math::</span>

<span class="sd">        \tau_k = \Braket{\Psi_k^{\tgt}}{\Psi_k(T)},</span>

<span class="sd">    in Hilbert space, or</span>

<span class="sd">    .. math::</span>

<span class="sd">        \tau_k = \tr\left[\Op{\rho}_k^{\tgt\,\dagger}\Op{\rho}_k(T)\right]</span>

<span class="sd">    in Liouville space, where $\ket{\Psi_k}$ or $\Op{\rho}_k$ are the elements</span>
<span class="sd">    of `fw_states_T`, and $\ket{\Psi_k^{\tgt}}$ or $\Op{\rho}^{\tgt}$ are the</span>
<span class="sd">    target states from the :attr:`~.Objective.target` attribute of the</span>
<span class="sd">    objectives. If `tau_vals` are None, they will be calculated internally.</span>

<span class="sd">    $N$ is the number of objectives, and $w_k$ is an optional weight for each</span>
<span class="sd">    objective. For any objective that has a (custom) `weight` attribute, the</span>
<span class="sd">    $w_k$ is taken from that attribute; otherwise, $w_k = 1$. The weights, if</span>
<span class="sd">    present, are not automatically normalized, they are assumed to have values</span>
<span class="sd">    such that the resulting $f_{\tau}$ lies in the unit circle of the complex</span>
<span class="sd">    plane. Usually, this means that the weights should sum to $N$. The</span>
<span class="sd">    exception would be for mixed target states, where the weights should</span>
<span class="sd">    compensate for the non-unit purity. The problem may be circumvented by</span>
<span class="sd">    using :func:`J_T_hs` for mixed target states.</span>

<span class="sd">    The `kwargs` are ignored, allowing the function to be used in an</span>
<span class="sd">    `info_hook`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tau_vals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_overlap</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="n">j</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">τ</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">τ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;krotov&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;τ is None in f_tau&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">τ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">τ</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">objectives</span><span class="p">)</span></div>


<div class="viewcode-block" id="F_ss"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.F_ss">[docs]</a><span class="k">def</span> <span class="nf">F_ss</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;State-to-state phase-insensitive fidelity</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_{\text{ss}} = \frac{1}{N} \sum_{k=1}^{N} w_k \Abs{\tau_k}^2</span>
<span class="sd">        \quad\in [0, 1]</span>

<span class="sd">    with $N$, $w_k$ and $\tau_k$ as in :func:`f_tau`.</span>

<span class="sd">    The `kwargs` are ignored, allowing the function to be used in an</span>
<span class="sd">    `info_hook`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># get the absolute square, analogously to the f_tau function above</span>
        <span class="n">tau_vals_abssq</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">_overlap</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">psi</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tau_vals_abssq</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">tau_vals</span><span class="p">]</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">f_tau</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals_abssq</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">imag</span>
    <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="J_T_ss"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.J_T_ss">[docs]</a><span class="k">def</span> <span class="nf">J_T_ss</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;State-to-state phase-insensitive functional  $J_{T,\text{ss}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        J_{T,\text{ss}} = 1 - F_{\text{ss}} \quad\in [0, 1].</span>

<span class="sd">    All arguments are passed to :func:`F_ss`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">F_ss</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">)</span></div>


<div class="viewcode-block" id="chis_ss"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.chis_ss">[docs]</a><span class="k">def</span> <span class="nf">chis_ss</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;States $\ket{\chi_k}$ for functional $J_{T,\text{ss}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Ket{\chi_k}</span>
<span class="sd">        = -\frac{\partial J_{T,\text{ss}}}{\partial \bra{\Psi_k(T)}}</span>
<span class="sd">        = \frac{1}{N} w_k \tau_k \Ket{\Psi^{\tgt}_k}</span>

<span class="sd">    with $\tau_k$ and $w_k$ as defined in :func:`f_tau`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objectives</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">τ</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
        <span class="c1"># `obj.target` is assumed to be the &quot;target state&quot; (gate applied to</span>
        <span class="c1"># `initial_state`)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">τ</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">τ</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="F_sm"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.F_sm">[docs]</a><span class="k">def</span> <span class="nf">F_sm</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Square-modulus fidelity</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_{\text{sm}} = \Abs{f_{\tau}}^2 \quad\in [0, 1].</span>

<span class="sd">    All arguments are passed to :func:`f_tau` to evaluate $f_{\tau}$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f_tau</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="J_T_sm"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.J_T_sm">[docs]</a><span class="k">def</span> <span class="nf">J_T_sm</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Square-modulus functional  $J_{T,\text{sm}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        J_{T,\text{sm}} = 1 - F_{\text{sm}} \quad\in [0, 1]</span>

<span class="sd">    All arguments are passed to :func:`f_tau` while evaluating $F_{\text{sm}}$</span>
<span class="sd">    in :func:`F_sm`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">F_sm</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">)</span></div>


<div class="viewcode-block" id="chis_sm"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.chis_sm">[docs]</a><span class="k">def</span> <span class="nf">chis_sm</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;States $\ket{\chi_k}$ for functional $J_{T,\text{sm}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Ket{\chi_k}</span>
<span class="sd">        = -\frac{\partial J_{T,\text{sm}}}{\partial \bra{\Psi_k(T)}}</span>
<span class="sd">        = \frac{1}{N^2} w_k \sum_{j}^{N} w_j\tau_j\Ket{\Psi^{\tgt}_k}</span>

<span class="sd">    with optional weights $w_k$, cf. :func:`f_tau` (default: :math:`w_k=1`). If</span>
<span class="sd">    given, the weights should generally sum to $N$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sum_of_w_tau</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">τ</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">):</span>
            <span class="n">sum_of_w_tau</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">τ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sum_of_w_tau</span> <span class="o">+=</span> <span class="n">τ</span>

    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objectives</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objectives</span><span class="p">:</span>
        <span class="c1"># `obj.target` is assumed to be the &quot;target state&quot; (gate applied to</span>
        <span class="c1"># `initial_state`)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span> <span class="o">*</span> <span class="n">sum_of_w_tau</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span> <span class="o">*</span> <span class="n">sum_of_w_tau</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="F_re"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.F_re">[docs]</a><span class="k">def</span> <span class="nf">F_re</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Real-part fidelity</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_{\text{re}} = \Re[f_{\tau}] \quad\in \begin{cases}</span>
<span class="sd">            [-1, 1] &amp; \text{in Hilbert space} \\</span>
<span class="sd">            [0, 1] &amp; \text{in Liouville space.}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    All arguments are passed to :func:`f_tau` to evaluate $f_{\tau}$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">f_tau</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">)</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="J_T_re"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.J_T_re">[docs]</a><span class="k">def</span> <span class="nf">J_T_re</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Real-part functional $J_{T,\text{re}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        J_{T,\text{re}} = 1 - F_{\text{re}} \quad\in \begin{cases}</span>
<span class="sd">            [0, 2] &amp; \text{in Hilbert space} \\</span>
<span class="sd">            [0, 1] &amp; \text{in Liouville space.}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    All arguments are passed to :func:`f_tau` while evaluating $F_{\text{re}}$</span>
<span class="sd">    in :func:`F_re`.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the target states are mixed, $J_{T,\text{re}}$ may take</span>
<span class="sd">        negative values (for `fw_states_T` that are &quot;in the right direction&quot;,</span>
<span class="sd">        but more pure than the target states). In this case, you may consider</span>
<span class="sd">        using :func:`J_T_hs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">F_re</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">)</span></div>


<div class="viewcode-block" id="chis_re"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.chis_re">[docs]</a><span class="k">def</span> <span class="nf">chis_re</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;States $\ket{\chi_k}$ for functional $J_{T,\text{re}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Ket{\chi_k}</span>
<span class="sd">        = -\frac{\partial J_{T,\text{re}}}{\partial \bra{\Psi_k(T)}}</span>
<span class="sd">        = \frac{1}{2N} w_k \Ket{\Psi^{\tgt}_k}</span>

<span class="sd">    with optional weights $w_k$, cf. :func:`f_tau` (default: :math:`w_k=1`). If</span>
<span class="sd">    given, the weights should generally sum to $N$.</span>

<span class="sd">    Note: `tau_vals` are ignored, but are present to satisfy the requirments of</span>
<span class="sd">    the `chi_constructor` interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">objectives</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objectives</span><span class="p">:</span>
        <span class="c1"># `obj.target` is assumed to be the &quot;target state&quot; (gate applied to</span>
        <span class="c1"># `initial_state`)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="J_T_hs"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.J_T_hs">[docs]</a><span class="k">def</span> <span class="nf">J_T_hs</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Hilbert-Schmidt distance measure functional $J_{T,\text{hs}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        J_{T,\text{hs}}</span>
<span class="sd">            = \frac{1}{2N} \sum_{k=1}^{N}</span>
<span class="sd">                w_k \Norm{\Op{\rho}_k(T) - \Op{\rho}_k^{\tgt}}_{\text{hs}}^2</span>
<span class="sd">        \quad \in \begin{cases}</span>
<span class="sd">            [0, 2] &amp; \text{in Hilbert space} \\</span>
<span class="sd">            [0, 1] &amp; \text{in Liouville space}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    in Liouville space (using the Hilbert-Schmidt norm), or equivalently with</span>
<span class="sd">    $\ket{\Psi_k(T)}$ and $\ket{\Psi_k^{tgt}}$ in Hilbert space. The functional</span>
<span class="sd">    is evaluated as</span>

<span class="sd">    .. math::</span>

<span class="sd">        J_{T,\text{hs}}</span>
<span class="sd">            = \frac{1}{2N} \sum_{k=1}^{N} w_k \left(</span>
<span class="sd">                \Norm{\Op{\rho}_k(T)}_{\text{hs}}^2</span>
<span class="sd">                + \Norm{\Op{\rho}^{\tgt}}_{\text{hs}}^2</span>
<span class="sd">                - 2 \Re[\tau_k]</span>
<span class="sd">            \right)</span>

<span class="sd">    where the $\Op{\rho}_k$ are the elements of `fw_states_T`,</span>
<span class="sd">    the $\Op{\rho}_k^{\tgt}$ are the target states from the</span>
<span class="sd">    :attr:`~.Objective.target` attribute of the objectives,</span>
<span class="sd">    and the $\tau_k$ are the elements of `tau_vals` (which</span>
<span class="sd">    will be calculated internally if passed as None).</span>

<span class="sd">    The $w_k$ are optional weights, cf. :func:`f_tau`. If</span>
<span class="sd">    given, the weights should generally sum to $N$.</span>

<span class="sd">    The `kwargs` are ignored, allowing the function to be used in an</span>
<span class="sd">    `info_hook`.</span>


<span class="sd">    Note:</span>
<span class="sd">        For pure states (or Hilbert space states), $J_{T,\text{hs}}$ is</span>
<span class="sd">        equivalent to $J_{T,\text{re}}$, cf. :func:`J_T_re`. However, the</span>
<span class="sd">        backward-propagated states $\chi_k$ obtained from the two functionals</span>
<span class="sd">        (:func:`chis_re` and :func:`chis_hs`) are *not* equivalent. This may</span>
<span class="sd">        result in a vastly different optimization landscape that requires a</span>
<span class="sd">        significantly different value of the $\lambda_a$ value that regulates</span>
<span class="sd">        the overall magnitude of the pulse updates (given in `pulse_options` in</span>
<span class="sd">        :func:`.optimize_pulses`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tau_vals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_overlap</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="s1">&#39;l2&#39;</span>  <span class="c1"># qutip&#39;s name for HS-norm for state vectors</span>
    <span class="k">if</span> <span class="n">fw_states_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;oper&#39;</span><span class="p">:</span>
        <span class="n">hs</span> <span class="o">=</span> <span class="s1">&#39;fro&#39;</span>  <span class="c1"># qutip&#39;s name for HS-norm for density matrices</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ρ</span><span class="p">,</span> <span class="n">τ</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">objectives</span><span class="p">,</span> <span class="n">fw_states_T</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
        <span class="n">ρ_tgt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">ρ</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ρ_tgt</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">τ</span><span class="o">.</span><span class="n">real</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">ρ</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ρ_tgt</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">τ</span><span class="o">.</span><span class="n">real</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">objectives</span><span class="p">))</span></div>


<div class="viewcode-block" id="chis_hs"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.chis_hs">[docs]</a><span class="k">def</span> <span class="nf">chis_hs</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">objectives</span><span class="p">,</span> <span class="n">tau_vals</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;States $\Op{\chi}_k$ for functional $J_{T,\text{hs}}$</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Op{\chi}_k</span>
<span class="sd">        = -\frac{\partial J_{T,\text{sm}}}</span>
<span class="sd">                {\partial \langle\!\langle \Op{\rho}_k(T)\vert}</span>
<span class="sd">        = \frac{1}{2N} w_k</span>
<span class="sd">          \left(\Op{\rho}^{\tgt}_k - \Op{\rho}_k(T)\right)</span>

<span class="sd">    with optional weights $w_k$, cf. :func:`f_tau` (default: :math:`w_k=1`).</span>

<span class="sd">    This is derived from $J_{T,\text{hs}}$ rewritten in the abstract</span>
<span class="sd">    Hilbert-Schmidt notation :math:`\langle\!\langle a \vert b \rangle\!\rangle</span>
<span class="sd">    \equiv \tr[a^\dagger b]`:</span>

<span class="sd">    .. math::</span>

<span class="sd">        J_{T,\text{hs}} = \frac{-1}{2N} \sum_{k=1}^{N}  w_k \big(</span>
<span class="sd">            \underbrace{</span>
<span class="sd">            \langle\!\langle \Op{\rho}_k(T) \vert</span>
<span class="sd">                \Op{\rho}_k^{\tgt} \rangle\!\rangle</span>
<span class="sd">            + \langle\!\langle \Op{\rho}_k^{\tgt}\vert</span>
<span class="sd">                 \Op{\rho}_k(T) \rangle\!\rangle</span>
<span class="sd">            }_{=2\Re[\tau_k]}</span>
<span class="sd">            - \underbrace{</span>
<span class="sd">              \langle\!\langle \Op{\rho}_k(T) \vert</span>
<span class="sd">                \Op{\rho}_k(T) \rangle\!\rangle</span>
<span class="sd">            }_{=\Norm{\Op{\rho}_k(T)}_{\text{hs}}^2}</span>
<span class="sd">            - \underbrace{</span>
<span class="sd">              \langle\!\langle \Op{\rho}_k^{\tgt} \vert</span>
<span class="sd">                \Op{\rho}_k^{\tgt} \rangle\!\rangle</span>
<span class="sd">            }_{=\Norm{\Op{\rho}^{\tgt}}_{\text{hs}}^2}</span>
<span class="sd">        \big).</span>

<span class="sd">    Note: `tau_vals` are ignored, but are present to satisfy the requirments of</span>
<span class="sd">    the `chi_constructor` interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">objectives</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ρ</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">objectives</span><span class="p">,</span> <span class="n">fw_states_T</span><span class="p">):</span>
        <span class="n">ρ_tgt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">weight</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">ρ_tgt</span> <span class="o">-</span> <span class="n">ρ</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">ρ_tgt</span> <span class="o">-</span> <span class="n">ρ</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="F_avg"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.F_avg">[docs]</a><span class="k">def</span> <span class="nf">F_avg</span><span class="p">(</span>
    <span class="n">fw_states_T</span><span class="p">,</span> <span class="n">basis_states</span><span class="p">,</span> <span class="n">gate</span><span class="p">,</span> <span class="n">mapped_basis_states</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mf">1e-5</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Average gate fidelity</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_{\text{avg}}</span>
<span class="sd">            = \int \big\langle \Psi \big\vert</span>
<span class="sd">                \Op{O}^\dagger \DynMap[\ketbra{\Psi}{\Psi}] \Op{O} \big\vert</span>
<span class="sd">                \Psi \big\rangle \dd \Psi</span>

<span class="sd">    where $\Op{O}$ is the target `gate`, and $\DynMap$ represents the dynamical</span>
<span class="sd">    map from time zero to $T$.</span>

<span class="sd">    In Liouville space, this is numerically evaluated as</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_{\text{avg}} = \frac{1}{N (N+1)}</span>
<span class="sd">            \sum_{i,j=1}^N \left(</span>
<span class="sd">                \big\langle</span>
<span class="sd">                    \phi_i \big\vert</span>
<span class="sd">                    \Op{O}^\dagger \Op{\rho}_{ij} \Op{O} \big\vert</span>
<span class="sd">                    \phi_j</span>
<span class="sd">                \big\rangle</span>
<span class="sd">                + \big\langle</span>
<span class="sd">                    \phi_i \big\vert</span>
<span class="sd">                    \Op{O}^\dagger  \Op{\rho}_{jj} \Op{O} \big\vert</span>
<span class="sd">                    \phi_i</span>
<span class="sd">                \big\rangle</span>
<span class="sd">            \right),</span>

<span class="sd">    where :math:`\ket{\phi_i}` is the :math:`i`&#39;th element of `basis_states`,</span>
<span class="sd">    and :math:`\Op{\rho}_{ij}` is the :math:`(i-1) N + j`&#39;th element of</span>
<span class="sd">    `fw_states_T`, that is, :math:`\Op{\rho}_{ij} =</span>
<span class="sd">    \DynMap[\ketbra{\phi_i}{\phi_j}]`, with :math:`N` the dimension of the</span>
<span class="sd">    Hilbert space.</span>

<span class="sd">    In Hilbert space (unitary dynamics), this simplifies to</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_{\text{avg}} = \frac{1}{N (N+1)} \left(</span>
<span class="sd">                \Abs{\tr\left[\Op{O}^\dagger \Op{U}\right]}^2</span>
<span class="sd">                + \tr\left[\Op{O}^\dagger \Op{U} \Op{U}^\dagger \Op{O}\right]</span>
<span class="sd">            \right),</span>

<span class="sd">    where $\Op{U}$ the gate that maps `basis_states` to the result of a forward</span>
<span class="sd">    propagation of those basis states, stored in `fw_states_T`.</span>

<span class="sd">    Args:</span>
<span class="sd">        fw_states_T (list[qutip.Qobj]): The forward propagated states. For</span>
<span class="sd">            dissipative dynamics, this must be the forward propagation of the</span>
<span class="sd">            full basis of Liouville space, that is, all $N^2$ dyadic</span>
<span class="sd">            combinations of the Hilbert space logical basis states.</span>
<span class="sd">            For unitary dynamics, the $N$ forward-propagated `basis_states`.</span>
<span class="sd">        basis_states (list[qutip.Qobj]): The $N$ Hilbert space logical basis</span>
<span class="sd">            states</span>
<span class="sd">        gate (qutip.Qobj): The $N \times N$ quantum gate in the logical</span>
<span class="sd">            subspace, e.g. :func:`qutip.qip.gates.cnot`.</span>
<span class="sd">        mapped_basis_states (None or list[qutip.Qobj]): If given, the result of</span>
<span class="sd">            applying gate to `basis_states`. If not given, this will be</span>
<span class="sd">            calculated internally via :func:`mapped_basis`. It is recommended</span>
<span class="sd">            to pass pre-calculated `mapped_basis_states` when evaluating</span>
<span class="sd">            $F_{\text{avg}}$ repeatedly for the same target.</span>
<span class="sd">        prec (float): assert that the fidelity is correct at least up to the</span>
<span class="sd">            given precision. Mathematically, $F_{\text{avg}}$ is a real value.</span>
<span class="sd">            However, errors in the `fw_states_T` can lead to a small non-zero</span>
<span class="sd">            imaginary part. We assert that this imaginary part is below `prec`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># F_avg is not something you can optimize directly: Nobody has calculated</span>
    <span class="c1"># ∂(1-F_avg)/∂⟨ϕ|. This is why there is no J_T_avg, and why F_avg does not</span>
    <span class="c1"># follow the info_hook interface.</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_states</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gate</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Shape of gate is incompatible with number of basis states&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">fw_states_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;oper&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Evaluating F_avg for density matrices requires </span><span class="si">%d</span><span class="s2"> states &quot;</span>
                <span class="s2">&quot;(forward-propagation of all dyadic combinations of &quot;</span>
                <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> basis states), not </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_F_avg_rho</span><span class="p">(</span>
            <span class="n">fw_states_T</span><span class="p">,</span>
            <span class="n">basis_states</span><span class="p">,</span>
            <span class="n">gate</span><span class="p">,</span>
            <span class="n">mapped_basis_states</span><span class="p">,</span>
            <span class="n">imag_limit</span><span class="o">=</span><span class="n">prec</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fw_states_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;ket&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Evaluating F_avg for hilbert space states requires </span><span class="si">%d</span><span class="s2"> states &quot;</span>
                <span class="s2">&quot;(forward-propagation of all basis states), not </span><span class="si">%d</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_F_avg_psi</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">basis_states</span><span class="p">,</span> <span class="n">gate</span><span class="p">,</span> <span class="n">imag_limit</span><span class="o">=</span><span class="n">prec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid type of state: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fw_states_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_F_avg_rho</span><span class="p">(</span>
    <span class="n">fw_states_T</span><span class="p">,</span> <span class="n">basis_states</span><span class="p">,</span> <span class="n">gate</span><span class="p">,</span> <span class="n">mapped_basis_states</span><span class="p">,</span> <span class="n">imag_limit</span><span class="o">=</span><span class="mf">1e-10</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of F_avg in Liouville space&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mapped_basis_states</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mapped_basis_states</span> <span class="o">=</span> <span class="n">mapped_basis</span><span class="p">(</span><span class="n">gate</span><span class="p">,</span> <span class="n">basis_states</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_states</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">ρ_jj</span> <span class="o">=</span> <span class="n">fw_states_T</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># zero-based indices!</span>
        <span class="n">Oϕ_j</span> <span class="o">=</span> <span class="n">mapped_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">ρ_ij</span> <span class="o">=</span> <span class="n">fw_states_T</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># zero-based indices!</span>
            <span class="n">Oϕ_i</span> <span class="o">=</span> <span class="n">mapped_basis_states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">F</span> <span class="o">+=</span> <span class="n">_overlap</span><span class="p">(</span><span class="n">Oϕ_i</span><span class="p">,</span> <span class="n">ρ_ij</span><span class="p">(</span><span class="n">Oϕ_j</span><span class="p">))</span> <span class="o">+</span> <span class="n">_overlap</span><span class="p">(</span><span class="n">Oϕ_i</span><span class="p">,</span> <span class="n">ρ_jj</span><span class="p">(</span><span class="n">Oϕ_i</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">imag_limit</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%.2e</span><span class="s2"> &gt; </span><span class="si">%.2e</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">imag_limit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_F_avg_psi</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">,</span> <span class="n">basis_states</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">imag_limit</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implementation of F_avg in Hilbert space&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_states</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">gate</span><span class="p">(</span><span class="n">basis_states</span><span class="p">,</span> <span class="n">fw_states_T</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">O</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">U</span><span class="p">)</span><span class="o">.</span><span class="n">tr</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">U</span> <span class="o">*</span> <span class="n">U</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">O</span><span class="p">)</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">imag_limit</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%.2e</span><span class="s2"> &gt; </span><span class="si">%.2e</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">imag_limit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<div class="viewcode-block" id="gate"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.gate">[docs]</a><span class="k">def</span> <span class="nf">gate</span><span class="p">(</span><span class="n">basis_states</span><span class="p">,</span> <span class="n">fw_states_T</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gate that maps `basis_states` to `fw_states_T`</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; from qutip import ket</span>
<span class="sd">        &gt;&gt;&gt; basis = [ket(nums) for nums in [(0, 0), (0, 1), (1, 0), (1, 1)]]</span>
<span class="sd">        &gt;&gt;&gt; CNOT = qutip.Qobj(</span>
<span class="sd">        ...     [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]],</span>
<span class="sd">        ...     dims=[[2, 2], [2, 2]]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; fw_states_T = mapped_basis(CNOT, basis)</span>
<span class="sd">        &gt;&gt;&gt; U = gate(basis, fw_states_T)</span>
<span class="sd">        &gt;&gt;&gt; assert (U - CNOT).norm() &lt; 1e-15</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis_states</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">basis_states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">fw_states_T</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">basis_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fw_states_T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span></div>


<div class="viewcode-block" id="mapped_basis"><a class="viewcode-back" href="../../API/krotov.functionals.html#krotov.functionals.mapped_basis">[docs]</a><span class="k">def</span> <span class="nf">mapped_basis</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">basis_states</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply the gate `O` to `basis_states`.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; from qutip import ket</span>
<span class="sd">        &gt;&gt;&gt; basis = [ket(nums) for nums in [(0, 0), (0, 1), (1, 0), (1, 1)]]</span>
<span class="sd">        &gt;&gt;&gt; CNOT = qutip.Qobj(</span>
<span class="sd">        ...     [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]],</span>
<span class="sd">        ...     dims=[[2, 2], [2, 2]]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; states = mapped_basis(CNOT, basis)</span>
<span class="sd">        &gt;&gt;&gt; assert (states[0] - ket((0, 0))).norm() &lt; 1e-15</span>
<span class="sd">        &gt;&gt;&gt; assert (states[1] - ket((0, 1))).norm() &lt; 1e-15</span>
<span class="sd">        &gt;&gt;&gt; assert (states[2] - ket((1, 1))).norm() &lt; 1e-15  # swap (1, 1) ...</span>
<span class="sd">        &gt;&gt;&gt; assert (states[3] - ket((1, 0))).norm() &lt; 1e-15  # ... and (1, 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">complex</span><span class="p">(</span><span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">basis_states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">O</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">]</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Michael Goerz et al..
      <span class="lastupdated">Last updated on Jun 03, 2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>